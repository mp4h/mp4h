;;;
;;;  mp4h.mp4h -- Documentation for mp4h
;;;  Copyright 2000, Denis Barbier   <barbier@imacs.polytechnique.fr>
;;;

<set-var package=mp4h>
<set-var version=0.8.0>
<set-var title="MP4H - A Macro Processeur for HTML">

<include <get-var format>.out
    alt=<exit status=1
        message="This file has to be compiled with one of the following lines
   ../../src/mp4h -D format=html mp4h.mp4h -I .. > mp4h.html
   ../../src/mp4h -D format=pod mp4h.mp4h -I .. > mp4h.pod
">
>

<include lang.en>
<include list-tags>

;;;
;;;   Les caractères pour commentaires sont modifiés
;;;
<set-eol-comment "###">

<header>
<section "Introduction">

<para>
The <mp4h> software is a macro-processor specially designed to deal with
HTML documents.  It allows powerful programming constructs, with a
syntax familiar to HTML authors.
</para>

<para>
This software is based on
<URL src="http://www.metahtml.org/" name="<Meta-HTML>">,
written by Brian J. Fox,  Even if both syntaxes look similar, source
code is completely different.  Indeed, <Meta-HTML> was used as a part of
a more complex program, <WML>
(<URL src="http://www.engelschall.com/sw/wml/" name="Website Meta Language">)
written by Ralf S. Engelschall, and which i maintain since january 1999.
For licensing reasons, it was hard to hack <Meta-HTML> and so i decided
to write my own macro-processor.
</para>

<para>
Instead of rewriting it from scratch, i preferred using another
macro-processor engine. I chose
<URL src="http://www.gnu.org/software/m4/" name="GNU <m4>">,
written by René Seindal, because of its numerous advantages :
this software is stable, robust and very well documented.
This version of <mp4h> is derived from GNU <m4> version 1.4n, which is a
development version.
</para>

<para>
The <mp4h> software is not an HTML editor ; its unique goal is to
provide an easy way to define its own macros inside HTML documents.
There is no plan to add functionalities to automagically produce valid
HTML documents, if you want to clean up your code or validate it,
simply use a post-processor like
<URL src="http://www.w3.org/People/Raggett/tidy/" name="tidy">.
</para>

<section "Command line options">

<para>
Optional arguments are enclosed within square brackets.
All option synonyms have a similar syntax, so when a long option accepts
an argument, short option do too.
</para>

<para>
Syntax call is

<code>mp4h [options] [filename [filename] ...]</code>

Options are described below.  If no filename is specified, or if its
name is <file ->, then characters are read on standard input.
</para>

<subsection "Operation modes">

<option-list>
<option --help>display an help message and exit</option>
<option --version>output <mp4h> version information and exit</option>
<option -E --fatal-warnings>stop execution after first warning</option>
<option -Q --quiet --silent>suppress some warnings for builtins</option>
</option-list>

<subsection "Preprocessor features">

<option-list>
<option -I --include=<optmand DIRECTORY>>###
search this directory second for includes</option>
<option -D --define=<optmand NAME<optopt =VALUE>>>###
enter NAME has having VALUE, or empty</option>
<option -U --undefine=<optmand COMMAND>>###
delete builtin COMMAND</option>
</option-list>

<subsection "Limits control">

<option-list>
<option -H --hashsize=<optmand PRIME>>###
set symbol lookup hash table size (default 509)</option>
<option -L -nesting-limit=<optmand NUMBER>>###
change artificial nesting limit (default 250)</option>
</option-list>

<subsection "Debugging">

<option-list>
<option -d --debug=<optmand FLAGS>>###
set debug level (no FLAGS implies `aeq')</option>
<option -t --trace=<optmand NAME>>###
trace NAME when it will be defined</option>
<option -l --arglength=<optmand NUMBER>>###
restrict macro tracing size</option>
<option -o --error-output=<optmand FILE>>###
redirect debug and trace output</option>
</option-list>

<para>
Flags are any of:
<option-list>
<option t>trace for all macro calls, not only traceon'ed</option>
<option a>show actual arguments</option>
<option e>show expansion</option>
<option c>show before collect, after collect and after call</option>
<option x>add a unique macro call id, useful with c flag</option>
<option f>say current input file name</option>
<option l>say current input line number</option>
<option p>show results of path searches</option>
<option i>show changes in input files</option>
<option V>shorthand for all of the above flags</option>
</option-list>
</para>

<section "Description">

<para>
The <mp4h> software is a macro-processor, which means that keywords are
replaced by other text.  This chapter describes all primitives.
As <mp4h> has been specially designed for HTML documents, its syntax is
very similar to HTML, with tags and attributes.  An important feature
has no equivalent in HTML: comments until end of line.  All text
following three colons is discarded until end of line, like
<code>;;;  This is a comment</code>
</para>

###
###    Defining new macros
###

<subsection "Function Macros">

<para>
The definition of new tags is the most common task provided by <mp4h>.
As with HTML, macro names are case insensitive.  In this documentation,
only lowercase letters are used.
There are two kinds of tags: simple and complex. A simple tag has the
following form:
<code><name [attributes]></code>
whereas a complex tag looks like:
<code><name [attributs]>
body
</name></code>
</para>

<para>
<anchor name="noteattr">
In macro descriptions below, a slash indicates a complex tag, and a V
letter that attributes are read verbatim (without expansion) (see the
chapter on macro expansion for further details).
</para>

<tag:description define-tag complex>
<var name>
[attributes=verbatim]
[endtag=required]
[whitespace=delete]
</tag:description>

<para>
This function lets you define your own tags.  First argument is the
command name. Replacement text is the function body.

<undef foo>
<example>
<define-tag foo>bar</define-tag>
<foo>
</example>

Even if spaces have usually few incidence on HTML syntax, it is
important to note that
<code><define-tag foo>bar</define-tag></code>
and
<code><define-tag foo>
bar
</define-tag></code>
are not equivalent, the latter form contains two newlines that were not
present in the former.
</para>

<attributes:description>
<attributes:item "whitespace=delete">
Some spaces are suppressed in replacement text, in particular any
leading or trailing spaces, and newlines not enclosed within angle
brackets.

<attributes:item "endtag=required">
Define a complex tag

<undef foo>
<example>
<define-tag foo>bar</define-tag>
<foo>
</example>

<undef foo>
<example>
<define-tag foo endtag=required>;;;
body is: %body</define-tag>
<foo>Here it is</foo>
</example>

<attributes:item "attributes=verbatim">
By default attributes are expanded before text is replaced. If this
attribute is used, attributes are inserted into replacement text without
expansion.

<undef foo bar>
<example>
<define-tag bar>quux</define-tag>
<define-tag foo attributes=verbatim endtag=required>
Body: %ubody
Attributes: %uattributes
</define-tag>
<foo txt="<bar>">Here we go</foo>
</example>
</attributes:description>

<tag:description provide-tag complex>
<var nom>
[attributes=verbatim]
[endtag=required]
[whitespace=delete]
</tag:description>

<para>
This command is similar to the previous one, except that no operation is
performed if this command was still defined.
</para>

<tag:description let>
<var new> <var old>
</tag:description>

<para>
Copy a function. This command is useful to save a macro definition
before redefining it.
</para>

<undef foo bar>
<example>
<define-tag foo>one</define-tag>
<let bar foo>
<define-tag foo>two</define-tag>
<foo><bar>
</example>

<tag:description undef>
<var name>
</tag:description>

<para>
Delete a command definition.
</para>

<undef foo>
<example>
<define-tag foo>one</define-tag>
<undef foo>
<foo>
</example>

###
###    Variable functions
###

<subsection "Variables">

<para>
Variables are a special case of simple tags, because they do not accept
attributes. In fact their use is different, because variables contain
text whereas macros act like operators.
A nice feature concerning variables is their manipulation as arrays.
Indeed variables can be considered like newline separated lists, which
will allow powerful manipulation functions as we will see below.
</para>

<tag:description set-var>
<var name>[=<var value>]
[<var name>[=<var value>]] ...
</tag:description>

<para>
This command sets variables.
</para>

<tag:description set-var-verbatim verbatim>
<var nom>[=<var valeur>]
[<var nom>[=<var valeur>]] ...
</tag:description>

<para>
As above but attributes are read verbatim.
</para>

<tag:description get-var>
<var name>
[<var name>] ...
</tag:description>

<para>
Show variable contents. If a numeric value within square brackets is
appended to a variable name, it represents the index of an array.
The first index of arrays is 0 by convention.
</para>

<example>
<set-var version="0.10.1">
This is version <get-var version>
</example>

<example>
<set-var foo="0
1
2
3">
<get-var foo[2] foo[0] foo>
</example>

<tag:description get-var-once verbatim>
<var name>
[<var name>] ...
</tag:description>

<para>
As above but attributes are not expanded.
</para>

<undef foo>
<example>
<define-tag foo>0.10.1</define-tag>
<set-var version="<foo>">Here is version <get-var version>
<set-var-verbatim version="<foo>">Here is version <get-var version>
<set-var-verbatim version="<foo>">Here is version <get-var-once version>
</example>

<tag:description preserve>
<var nom>
</tag:description>

<para>
All variables are global, there is no variable or macro scope.
For this reason a stack is used to preserve variables.
When this command is invoked, the first argument is the name of a
variable. The value of this variable is put at the top of the stack and
this variable is reset to an empty string.
</para>

<tag:description restore>
<var nom>
</tag:description>

<para>
This is the opposite: first argument is a variable name, this variable
is set to the value found at the top of the stack, and this value is
pooped.
</para>

<tag:description unset-var>
<var name>
[<var name>] ...
</tag:description>

<para>
Undefine variables.
</para>

<tag:description var-exists>
<var nom>
</tag:description>

<para>
Returns <true> when this variable exists.
</para>

<tag:description increment>
<var name>
[by=<var value>]
</tag:description>

<para>
Increment the variable whose name is the first argument.  Default
increment is one.
</para>

<attributes:description>
<attributes:item "by=<var value>">
Change increment amount.
</attributes:description>

<example>
<set-var i=10>
<get-var i>
<increment i><get-var i>
<increment i by="-3"><get-var i>
</example>

<tag:description decrement>
<var name>
[by=<var value>]
</tag:description>

<para>
Decrement the variable whose name is the first argument.  Default
decrement is one.
</para>

<attributes:description>
<attributes:item "by=<var value>">
Change decrement amount.
</attributes:description>

<example>
<set-var i=10>
<get-var i>
<decrement i><get-var i>
<decrement i by="3"><get-var i>
</example>

<tag:description copy-var>
<var src>
<var dest>
</tag:description>

<para>
Copie a variable into another.
</para>

<example>
<set-var i=10>
<copy-var i j>
<get-var j>
</example>

<tag:description defvar>
<var name>
<var value>
</tag:description>

<para>
If this variable is not defined or is defined to an empty string, then
it is set to the second argument.
</para>

<example>
<unset-var title>
<defvar title "Title"><get-var title>
<defvar title "New title"><get-var title>
</example>

<tag:description symbol-info>
<var name>
</tag:description>

<para>
Show informations on symbols.  If it is a variable name, the <command
STRING> word is printed as well as the number of lines contained within
this variable.

If it is a macro name, one of the following messages is printed:
<command PRIM COMPLEX>, <command PRIM TAG>,
<command USER COMPLEX> or <command USER TAG>
</para>

<example>
<set-var x="0\n1\n2\n3\n4">
<define-tag foo>bar</define-tag>
<define-tag bar endtag=required>;;;
quux</define-tag>
<symbol-info x>
<symbol-info symbol-info>
<symbol-info define-tag>
<symbol-info foo>
<symbol-info bar>
</example>

###
###    String functions
###

<subsection "String Functions">

<tag:description string-length>
<var string>
</tag:description>

<para>
Prints the length of the string.
</para>

<example>
<set-var foo="0
1
2
3">
<string-length <get-var foo>>
<set-var foo="0 1 2 3">
<set-var l=<string-length <get-var foo>>>
<get-var l>
</example>

<tag:description downcase>
<var string>
</tag:description>

<para>
Convert to lowercase letters.
</para>

<example>
<downcase "Does it work?">
</example>

<tag:description upcase>
<var string>
</tag:description>

<para>
Convert to uppercase letters.
</para>

<example>
<upcase "Does it work?">
</example>

<tag:description capitalize>
<var string>
</tag:description>

<para>
Convert to a title, with a capital letter at the beginning of every
word.
</para>

<example>
<capitalize "Does it work?">
</example>

<tag:description substring>
<var string>
[<var start> [<var end>]]
</tag:description>

<para>
Extracts a substring from a string.  First argument is original string,
second and third are respectively start and end indexes.  By convention
first character has a null index.
</para>

<example>
<set-var foo="abcdefghijk">
<substring <get-var foo> 4>
<substring <get-var foo> 4 6>
</example>

<tag:description subst-in-string>
<var string>
<var regexp>
[<var replacement>]
[singleline=true]
</tag:description>

<para>
Replace a regular expression in a string by a replacement text.
</para>

<example>
<set-var foo="abcdefghijk">
<subst-in-string <get-var foo> "[c-e]">
<subst-in-string <get-var foo> "([c-e])" "\\1 ">
</example>

<attributes:description>
<attributes:item "singleline=true">
when this attribute is used, the <command ^> symbol represents the
beginning of string and <command $> the end of string.
Otherwise they represent the beginning and end of lines.
</attributes:description>

<example>
<set-var foo="abcdefghijk\nabcdefghijk\nabcdefghijk">
<subst-in-string <get-var foo> ".$" "">
<subst-in-string <get-var foo> ".$" "" singleline=true>
</example>

<tag:description subst-in-var>
<var name>
<var regexp>
[<var replacement>]
[singleline=true]
</tag:description>

<para>
Performs substitutions inside variable content.
</para>

<tag:description string-eq>
<var string1>
<var string2>
[caseless=true]
</tag:description>

<para>
Returns <true> if first two arguments are equal.
</para>

<example>
1:<string-eq "aAbBcC" "aabbcc">
2:<string-eq "aAbBcC" "aAbBcC">
</example>

<attributes:description>
<attributes:item "caseless=true">
Comparison is case insensitive.
</attributes:description>

<example>
1:<string-eq "aAbBcC" "aabbcc" caseless=true>
2:<string-eq "aAbBcC" "aAbBcC" caseless=true>
</example>

<tag:description string-neq>
<var string1>
<var string2>
[caseless=true]
</tag:description>

<para>
Returns <true> if the first two arguments are not equal.
</para>

<example>
1:<string-neq "aAbBcC" "aabbcc">
2:<string-neq "aAbBcC" "aAbBcC">
</example>

<attributes:description>
<attributes:item "caseless=true">
Comparison is case insensitive.
</attributes:description>

<example>
1:<string-neq "aAbBcC" "aabbcc" caseless=true>
2:<string-neq "aAbBcC" "aAbBcC" caseless=true>
</example>

<tag:description string-compare>
<var string1>
<var string2>
[caseless=true]
</tag:description>

<para>
Compares two strings and returns one of the values less,
greater or equal depending on this comparison.
</para>

<example>
1:<string-compare "aAbBcC" "aabbcc">
2:<string-compare "aAbBcC" "aAbBcC">
</example>

<attributes:description>
<attributes:item "caseless=true">
Comparison is case insensitive.
</attributes:description>

<example>
1:<string-compare "aAbBcC" "aabbcc" caseless=true>
</example>

<tag:description match>
<var string>
<var regexp>
[caseless=true]
[action=report|extract|delete|startpos|endpos|length]
</tag:description>

<attributes:description>
<attributes:item "caseless=true">
Comparison is case insensitive.
<attributes:item "action=report">
Prints <true> if string contains regexp.
régulière, et rien sinon.
<attributes:item "action=extract">
Prints the expression matching regexp in string.
<attributes:item "action=delete">
Prints the string without the expression matching regexp in string.
<attributes:item "action=startpos">
Prints the first char of the expression matching regexp in string.
If there is no match, returns <value -1>.
<attributes:item "action=endpos">
Prints the last char of the expression matching regexp in string.
If there is no match, returns <value -1>.
<attributes:item "action=length">
Prints the length of the expression matching regexp in string.
</attributes:description>

<example>
1:<match "abcdefghijk" "[c-e]+">
2:<match "abcdefghijk" "[c-e]+" action=extract>
3:<match "abcdefghijk" "[c-e]+" action=delete>
4:<match "abcdefghijk" "[c-e]+" action=startpos>
5:<match "abcdefghijk" "[c-e]+" action=endpos>
6:<match "abcdefghijk" "[c-e]+" action=length>
</example>

<tag:description char-offsets>
<var string>
<var character>
[caseless=true]
</tag:description>

<para>
Prints an array containing indexes where the character appear in the
string.
</para>

<attributes:description>
<attributes:item "caseless=true">
Comparison is case insensitive.
</attributes:description>

<example>
1:<char-offsets "abcdAbCdaBcD" a>
2:<char-offsets "abcdAbCdaBcD" a caseless=true>
</example>

<tag:description set-regexp-syntax>
[type=basic|extended]
</tag:description>

<para>
This command controls which regular expressions are used in the macros
described above.  There are only two possible values: basic and
extended.
The former are basic regular expressions and the latter are extended
regular expressions. By default extended regular expressions are used.
</para>

<example>
<set-var foo="abcdefghijk">
<set-regexp-syntax type=basic>
<subst-in-string <get-var foo> "([c-e]+)" ":\\1:">
<subst-in-string <get-var foo> "\\([c-e]\\{1,\\}\\)" ":\\1:">
<set-regexp-syntax type=extended>
<subst-in-string <get-var foo> "([c-e]+)" ":\\1:">
<subst-in-string <get-var foo> "\\([c-e]\\{1,\\}\\)" ":\\1:">
</example>

<tag:description get-regexp-syntax>
</tag:description>

<para>
Prints actual regexp type.
</para>

<example>
<get-regexp-syntax>
</example>

###
###    Array functions
###

<subsection "Tableaux">

<para>
Le programme <mp4h> permet de faire des manipulations simples sur les
tableaux. Le texte contenu à l'intérieur d'une variable peut être vu
indifféremment comme une seule chaîne de caractères, ou comme un tableau
de lignes séparées par des sauts de ligne. Ainsi, après
<code>
<set-var chiffres="0
1
2
3">
</code>
nous pouvons afficher soit le contenu de cette variable, soit une des
lignes.
<set-var chiffres="0\n1\n2\n3">
<example>
<get-var chiffres[2]>
<get-var chiffres>
</example>
</para>

<tag:description array-size>
<var nom>
</tag:description>

<para>
Affiche la taille du tableau dont le nom est passé en argument. Cette
taille est le nombre de lignes présentes dans la variable.
</para>

<example>
<array-size chiffres>
</example>

<tag:description array-append>
<var valeur>
<var nom>
</tag:description>

<para>
Ajoute une ou plusieurs lignes à la fin du tableau.
</para>

<example>
<array-append "10\n11\n12" chiffres>
<get-var chiffres>
</example>

<tag:description array-add-unique>
<var valeur>
<var nom>
[caseless=true]
</tag:description>

<para>
Ajoute une valeur à la fin du tableau si elle n'est pas déjà présente
dans ce tableau.
</para>

<example>
<array-add-unique 2 chiffres>
<get-var chiffres>
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
</attributes:description>

<tag:description array-concat>
<var nom1>
[<var nom2>] ...
</tag:description>

<para>
Concatène le contenu des tableaux dans la variable dont le nom est passé
en premier.
</para>

<example>
<set-var foo="foo">
<set-var bar="bar">
<array-concat foo bar><get-var foo>
</example>

<tag:description array-member>
<var valeur>
<var nom>
[caseless=true]
</tag:description>

<para>
Si la valeur est contenue dans le tableau, retourne l'indice de cette
valeur, sinon retourne <value -1>.
</para>

<example>
<array-member 11 chiffres>
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
</attributes:description>

<tag:description array-shift>
<var offset>
<var nom>
[start=<var début>]
</tag:description>

<para>
Cette commande permet de décaler les éléments du tableau. Le premier
argument est la valeur du décalage, et le second argument le nom de la
variable à manipuler. Si le décalage est négatif, les indices qui
tombent en dessous de 0 sont éliminés, et s'il est positif, les
premières valeurs sont remplies par des lignes vides.
</para>

<example>
<array-shift 2 chiffres>
Maintenant: <get-var chiffres>
<array-shift -4 chiffres>
Et là: <get-var chiffres>
</example>

<attributes:description>
<attributes:item "start=<var début>">
Indique le point de départ à partir duquel le décalage s'opère.
<example>
<array-shift -2 chiffres start=2><get-var chiffres>
</example>
</attributes:description>

<tag:description sort>
<var nom>
[caseless=true]
[numeric=true]
[sortorder=reverse]
</tag:description>

<para>
Trie les lignes d'un tableau par ordre alphabétique.
</para>

<example>
<sort chiffres><get-var chiffres>
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, le tri est fait indépendamment de la casse
des caractères.

<attributes:item "numeric=true">
Effectue un tri en comparant les valeurs numériquement, et non
alphabétiquement.
<example>
<sort chiffres numeric=true><get-var chiffres>
</example>

<attributes:item "sortorder=reverse">
Effectue le tri en ordre inverse
<example>
<sort chiffres numeric=true sortorder=reverse><get-var chiffres>
</example>
</attributes:description>

###
###    Numerical operators
###

<subsection "Opérateurs arithmétiques">

<para>
Les opérateurs suivants permettent de manipuler des nombres. Lorsque
tous les nombres sont des entiers, le résultat est un entier. Dans le
cas contraire, le résultat est un réel.
</para>

<tag:description add>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description substract>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description multiply>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description divide>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description min>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description max>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<example>
<add 1 2 3 4 5 6>
<add 1 2 3 4 5 6.>
</example>

<example>
<define-tag factorielle whitespace=delete>
<ifeq %0 1 1 <multiply %0 <factorielle <substract %0 1>>>>
</define-tag>
<factorielle 6>
</example>

<tag:description modulo>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Contrairement aux fonctions ci-dessus, la fonction modulo ne peut
prendre que deux arguments, qui sont obligatoirement des entiers.
</para>

<example>
<modulo 345 7>
<factorielle 6>
</example>

<para>
Les fonctions suivantes permettent de comparer des nombres, et
retournent <true> lorsque la comparaison est vraie et rien sinon. Si un
des arguments n'est pas un nombre, la comparaison est fausse.
</para>

<tag:description gt>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Retourne <true> si le premier argument est strictement supérieur au
second.
</para>

<tag:description lt>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Retourne <true> si le premier argument est strictement inférieur au
second.
</para>

<tag:description eq>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Retourne <true> si les deux arguments sont égaux.
</para>

<tag:description neq>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Retourne <true> si les deux arguments sont différents.
</para>

###
###    Relational operators
###

<subsection "Operateurs relationnels">

<tag:description not>
<var string>
</tag:description>

<para>
Retourne <true> si la chaîne de caractères est vide, et rien sinon.
</para>

<tag:description and>
<var string>
[<var string>] ...
</tag:description>

<para>
Retourne le dernier argument si tous les arguments sont non vides, sinon
ne retourne rien.
</para>

<tag:description or>
<var string>
[<var string>] ...
</tag:description>

<para>
Affiche le premier argument non nul.
</para>

###
###    Flow functions
###

<subsection "Fonctions de contrôle">

<tag:description group verbatim>
<var statement>
[<var statement>] ...
[quoted=true]
</tag:description>

<para>
Cette fonction a pour objectif de grouper une succession de commandes en une
seule. Des applications seront vues dans les exemples des commandes
suivantes.
</para>

<para>
Une autre utilisation de cette commande, moins intuitive mais tout aussi
importante, est de pouvoir mettre des sauts de ligne même si l'attribut
<attribute whitespace=delete> a été spécifié.
</para>

<example>
<define-tag texte1>
Ce texte est sur
3 lignes sans
whitespace=delete
</define-tag>
<define-tag texte2 whitespace=delete>
Ce texte est sur
3 lignes avec
whitespace=delete
</define-tag>
<define-tag texte3 whitespace=delete>
<group "Ce texte est sur
3 lignes avec
whitespace=delete">
</define-tag>
<texte1>
<texte2>
<texte3>
</example>

<para>
Notez dans l'exemple 2 que les sauts de ligne ont été supprimés, ce qui
a pour conséquence de coller des lettres qui ne doivent pas l'être.
</para>

<attributes:description>
<attributes:item "quoted=true">
Avec cet attribut, le résultat de l'évaluation est entouré de caractères
de contrôle, pour qu'il ne soit plus développé ensuite.
</attributes:description>

<undef foo>
<example>
<subst-in-string "=LT=define-tag foo>bar</define-tag>" "=LT=" "<">
<foo>
<subst-in-string "=LT=define-tag foo>quux</define-tag>" "=LT=" "<quote \"<\">">
<foo>
</example>

<tag:description if verbatim>
<var string>
<var then-clause>
[<var else-clause>]
</tag:description>

<para>
Si la chaîne de caractères passée en premier argument n'est pas vide, le
deuxième argument est exécuté, sinon c'est le troisième.
</para>

<example>
<define-tag test whitespace=delete>
<if %0 "oui" "non">
</define-tag>
<test "chaine">
<test "">
</example>

<tag:description ifeq verbatim>
<var string1>
<var string2>
<var then-clause>
[<var else-clause>]
</tag:description>

<para>
Si les deux chaînes de caractères passées en premier et deuxième
arguments sont identiques, le troisième argument est exécuté, sinon
c'est le quatrième.
</para>

<tag:description ifneq verbatim>
<var string1>
<var string2>
<var then-clause>
[<var else-clause>]
</tag:description>

<para>
Si les deux chaînes de caractères passées en premier et deuxième
arguments ne sont pas identiques, le troisième argument est exécuté,
sinon c'est le quatrième.
</para>

<tag:description when complex>
<var string>
</tag:description>

<para>
Quand la chaîne de caractères passée en premier argument n'est pas vide,
le corps de cette fonction est exécuté.
</para>

<tag:description while verbatim complex>
<var cond>
</tag:description>

<para>
Tant que la condition passée en premier argument est vérifiée, le corps
de cette fonction est exécuté.
</para>

<example>
<set-var i=10>
<while <gt <get-var i> 0>>;;;
  <get-var i> <decrement i>;;;
</while>
</example>

<tag:description foreach complex>
<var variable>
<var array>
[start=<var start>]
[end=<var end>]
[step=<var pas>]
</tag:description>

<para>
Cette commande est similaire à la commande <command foreach> de Perl ; 
une variable prend successivement toutes les valeurs stockées dans un
tableau, et le corps de la fonction est exécuté pour chacune de ces
valeurs.

Le premier argument est le nom de la variable qui va prendre les
différentes valeurs, et le deuxième argument est le nom de la variable
qui contient le tableau de valeurs.
</para>

<example>
<set-var x="1\n2\n3\n4\n5\n6">
<foreach i x><get-var i> </foreach>
</example>

<attributes:description>
<attributes:item "start=<var start>">
La boucle commence à l'indice indiqué par cet attribut.
<example>
<set-var x="1\n2\n3\n4\n5\n6">
<foreach i x start=3><get-var i> </foreach>
</example>

<attributes:item "end=<var end>">
La boucle termine à l'indice indiqué par cet attribut.
<example>
<set-var x="1\n2\n3\n4\n5\n6">
<foreach i x end=3><get-var i> </foreach>
</example>

<attributes:item "step=<var pas>">
Lorsqu'un pas est spécifié, 
Au lieu de prendre toutes les valeurs du tableau, 
Si le pas est négatif, la boucle est inversée.
<example>
<set-var x="1\n2\n3\n4\n5\n6">
<foreach i x step=2><get-var i> </foreach>
<foreach i x step=-2><get-var i> </foreach>
</example>
</attributes:description>

<tag:description var-case verbatim>
<var var1>=<var valeur1> <var action1>
[<var var2>=<var valeur2> <var action2> ...
</tag:description>

<para>
Cette commande permet de faire plusieurs tests en une seule instruction.

<example>
<set-var i=0>
<define-tag test whitespace=delete>
<var-case
  x=1   <group <increment i> x<get-var i>>
  x=2   <group <decrement i> x<get-var i>>
  y=1   <group <increment i> y<get-var i>>
  y=2   <group <decrement i> y<get-var i>>
>
</define-tag>
<set-var x=1 y=2><test>
<set-var x=0 y=2><test>
</example>
</para>

<tag:description break>
</tag:description>

<para>
Cette commande fait sortir de la boucle <command while>
la plus interne.
</para>

<example>
<set-var i=10>
<while <gt <get-var i> 0>>;;;
  <get-var i> <decrement i>;;;
  <ifeq <get-var i> 5 <break>>;;;
</while>
</example>

<tag:description warning>
</tag:description>

<para>
Affiche le message donné en arguments sur l'erreur standard.
</para>

<tag:description exit>
[status=<var rc>]
[message=<var chaine>]
</tag:description>

<para>
Interrompt immédiatement le programme. L'attribut <attribute message>
permet d'afficher une information sur l'erreur standard, pour indiquer
la cause de l'arrêt du programme. Si l'attribut <attribute status> est
utilisé, il indique quel code le programme retourne (-1 par défaut).
</para>

<tag:description at-end-of-file>
</tag:description>

<para>
Cette commande est spéciale, puisqu'elle stocke ses arguments
temporairement. Ils seront traités lorsque le fichier d'entrée est
entièrement lu.
</para>

###
###    File functions
###

<subsection "Fonctions sur les fichiers">

<tag:description directory-contents>
<var dirname>
[matching=regexp]
</tag:description>

<para>
Le nom d'un répertoire est passé en argument. Cette commande 
affiche la liste des noms de fichiers présents dans ce répertoire,
séparés par des sauts de ligne.
</para>

<example>
<directory-contents . matching=".*\\.mp4h$">
</example>

<tag:description file-exists>
<var filename>
</tag:description>

<para>
Affiche <true> si le fichier dont le nom est passé en argument est
trouvé, et rien sinon.
</para>

<tag:description get-file-properties>
<var filename>
</tag:description>

<para>
Affiche un tableau d'informations sur le fichier dont le nom est donné
en argument. Les informations sont dans l'ordre : la taille du fichier,
son type, la date du dernier changement de l'inode (en secondes depuis
le 1er janvier 1970), la date de la dernière modification du fichier, la
date du dernier accès au fichier, le nom du propriétaire du fichier, et
le nom du groupe.
</para>

<example>
<get-file-properties mp4h.mp4h>
</example>

<tag:description include>
<var filename>
[alt=<var action>]
[verbatim=true]
</tag:description>

<para>
Lit les données contenues dans le fichier passé en argument.
</para>

<attributes:description>
<attributes:item "alt=<var texte>">
Si le fichier n'est pas trouvé, le texte alternatif est affiché. Si cet
attribut est absent et que le fichier n'est pas trouvé, le programme
s'arrête.

<attributes:item "verbatim=true">
Avec cet attribut, le contenu du fichier est inclus sans être modifié
par <mp4h>.
</attributes:description>

<tag:description comment complex>
</tag:description>

<para>
Le corps de cette balise est supprimé.
</para>

<tag:description eol-comment>
</tag:description>

<para>
Permet de modifier les caractères servant de commentaires.
</para>

###
###    Debugging
###

<subsection "Aide au déboguage">

<para>
Lorsque les constructions deviennent complexes, il peut être ardu de comprendre
ce qui cloche dans ce qu'on a écrit. Les fonctions ci-dessous permettent
d'afficher certaines informations. Le déboguage reste cependant délicat, et est
une partie de <mp4h> à améliorer.
</para>

<tag:description function-def>
<var nom>
</tag:description>

<para>
Affiche le texte de remplacement de la fonction. Par exemple, la commande qui
affiche les exemples à été définie ainsi:
<example>
<function-def example>
</example>

</para>

<tag:description debugmode>
<var string>
</tag:description>

<para>
Cette commande prend le même argument que l'option <optflag d>.
</para>

<tag:description debugfile>
<var fichier>
</tag:description>

<para>
Indique dans quel fichier les instructions de déboguage doivent être
écrites. Si le nom de fichier est vide, l'affichage de ces instructions
se fait de nouveau dans la sortie erreur standard. Si le nom du fichier
est <file ->, l'affichage est supprimé.
</para>

<para>
Il n'existe aucun moyen pour insérer ces instructions à l'intérieur du
document post-traité.
</para>

<tag:description debugging-on>
<var nom>
[<var nom>] ...
</tag:description>

<para>
Les commandes dont les noms sont passés en argument sont «tracées»,
c'est-à-diree que les informations demandées au travers de l'option <optflag d>
et de la commande <command debugmode> sont affichées lors de chaque appel de
la fonction.
</para>

<tag:description debugging-off>
<var nom>
[<var nom>] ...
</tag:description>

<para>
Fonction inverse de la précédente.
</para>

###
###    Misc
###

<subsection "Divers">

<tag:description __file__>
[<var nom>]
</tag:description>

<para>
Sans argument, la fonction retourne le nom du fichier en train d'être
traité. S'il y a un argument, il est le nom du fichier retourné par les
prochains appels à cette fonxction.
</para>

<tag:description __line__>
[<var numéro>]
</tag:description>
<para>
Sans argument, la fonction retourne le numéro de la ligne dans le
fichier en train d'être traité. S'il y a un argument, il est le numéro
de la ligne retourné par les prochains appels à cette fonxction.
</para>

<example>
Ceci est le fichier <__file__>, ligne <__line__>.
</example>

<para>
En fait, si vous regardez le fichier source, vous vous apercevrez que le
numéro de la ligne n'est pas correct.
d'être traité.
</para>

<tag:description __version__>
</tag:description>

<para>
Affiche le numéro de version de <mp4h>.
</para>

<tag:description date>
[epoch]
</tag:description>

<para>
Affiche l'heure locale correspondant au temps epoch donné en argument.
Lorsqu'il n'y a pas d'argument, l'heure actuelle est affichée.
</para>

<example>
<date>
<set-var info=<get-file-properties <__file__>>>
<date <get-var info[2]>>
</example>

<tag:description timer>
</tag:description>

<para>
Affiche le temps écoulé depuis le précédent appel à cette fonction.
Le temps affiché est le nombre de cycles d'horloge, et est donc
dépendant de la vitesse du processeur.
</para>

<example>
Le temps écoulé est mesuré en cycles d'horloge. Depuis le début de la
compilation de cette documentation par <mp4h>, voici le nombre de cycles
écoulés:
<timer>
</example>

<section "Schéma d'expansion des macros">

<para>
Cette partie décrit les mécanismes utilisés pour le remplacement des
macros. Elle se veut aussi précise que possible, aussi n'hésitez pas à
<URL src="mailto:barbier@imacs.polytechnique.fr" name="me signaler">
toute erreur ou omission.
</para>

<subsection "Généralités">

<undef foo bar>
Commençons par donner des exemples de définition de balises:
<example>
<define-tag foo>;;;
Ceci est un exemple de balise simple;;;
</define-tag>;;;
<define-tag bar endtag=required>;;;
Ceci est un exemple de balise complexe;;;
</define-tag>;;;
<foo>
<bar>Corps de la fonction</bar>
</example>

<undef href mail1 mail2 show-attributes show1 show2 bar>
<para>
Les commandes ainsi définies peuvent avoir des attributs, comme toute
balise HTML. Pour que ces attributs se retrouvent dans le texte de
remplacement, les conventions suivantes ont été adoptées:
<list>
<item>Les attributs sont numérotés à partir de 0. Dans le texte de
remplacement, <value %0> sera remplacé par le 1er attribut, <value %1>
par le 2e attribut, etc. Comme le nombre d'attribut n'est pas limité,
les lettres <value %20> seront remplacés par le vingt-et-unième
argument, et pas par le 3e argument suivi d'un 0.
<example>
<define-tag href>;;;
<a href="%0">%1</a>;;;
</define-tag>;;;
<href http://www.gimp.org "The Gimp">
</example>

<item>La séquence <value %#> affiche le nombre d'attributs passés
à la commande.

<item>La séquence <value %%> est remplacée par un <value %>, ce qui est
utile pour des définitions imbriquées.
<example>
<define-tag externe>;;;
Externe, nombre d'attributs: %#
<define-tag interne1>;;;
Interne1, nombre d'attributs: %#;;;
</define-tag>;;;
<define-tag interne2>;;;
Interne2, nombre d'attributs: %%#;;;
</define-tag>;;;
<interne1 %attributes et quelques autres>
<interne2 %attributes et quelques autres>
</define-tag>
<externe liste attributs>
</example>

<item>Les caractères <value %attributes> sont remplacés par la liste 
des arguments, séparés par un espace.
<example>
<define-tag mail1>;;;
<set-var %attributes>;;;
<get-var name>
<get-var mail>
</define-tag>;;;
<set-var name="" mail="">
<mail1 name="Dr. Foo" mail="hello@foo.com">
</example>

<item>Les caractères <value %body> sont remplacés par le corps de la
commande, dans le cas d'une balise complexe.
<example>
<define-tag mail2 endtag=required>;;;
<set-var %attributes>;;;
<a href="mailto:<get-var mail>">%body</a>
</define-tag>;;;
<mail2 mail="hello@foo.com">;;;
<img src="photo.png" alt="Dr. Foo" border=0>;;;
</mail2>
</example>

<item>Les deux formes ci-dessus possèdent une forme alternative, où la
liste est séparée par des sauts de lignes au lieu d'espaces. Il s'agit
des formes <value %Aattributes> et <value %Abody>, le <value A> voulant
dire array (tableau en français).
<example>
<define-tag show-attributes>;;;
<set-var list="%Aattributes" i=0>;;;
<foreach attr list>;;;
%<get-var i>: <get-var attr>
<increment i>;;;
</foreach>;;;
</define-tag>;;;
<show-attributes name="Dr. Foo" mail="hello@foo.com">
</example>

<item>Une autre forme alternative est obtenue en remoplaçant le <value
A> par <value U>, auquel cas le texte est remplacé mais n'est lui-même
pas évalué. Cela n'a de sens que si la commande a été déclarée avec
l'attribut <attribute attributes=verbatim>, parce que dans le cas
contraire les arguments sont développés avant que ces substitutions
n'aient lieu.
<example>
<define-tag show1>;;;
Avant développement: %Uattributes
Après développement: %attributes
</define-tag>;;;
<define-tag show2 attributes=verbatim>;;;
Avant développement: %Uattributes
Après développement: %attributes
</define-tag>;;;
<define-tag bar>et hop %attributes</define-tag>;;;
<show1 <bar la boum>>
<show2 <bar la boum>>
</example>

<item>Les modificateurs <value A> et <value U> peuvent être combinés.
</list>
</para>

<note>
Le mécanisme de lecture des instructions est complètement différent dans
<Meta-HTML> et dans <mp4h>. Avec <Meta-HTML>, il est parfois nécessaire
d'avoir recours à d'autres constructions, comme <value %xbody> et <value
%qbody>. Celles-ci n'ont pas lieu d'être avec <mp4h>, mais pour être au
plus compatible avec <Meta-HTML>, <mp4h> les reconnait aussi et elles
ont exactement le même rôle que <value %body>. Une autre particularité
non mentionnée ci-dessus, qui existe aussi pour des raisons de
compatibilité avec <Meta-HTML>, est le fait que pour des balises
simples, <value %body> est un synonyme de <value %attributes>. Ces
fonctionnalités sont actuellement comprises dans <mp4h>, mais peuvent
très bien être supprimées dans les versions futures.
</note>

<subsection "Attributs">

<para>
Les attributs sont séparés par un ou plusieurs espaces, tabulations ou
sauts de lignes, et chaque attribut doit être une entité complète de
<mp4h>. Par exemple, avec les définitionsa ci-dessus,
<full-command bar> ne peut pas être un attribut,
parce que la commande <full-command bar> est complexe.
En revanche, il est possible d'écrire
<code><foo <foo>></code>
ou même
<code><foo <foo name=src url=ici>></code>
Dans les deux exemples ci-dessus, la commande <command foo> a un seul
attribut.
</para>

<undef foo bar>
<para>
Dans certains cas, il est nécessaire de regrouper ensemble plusieurs
chaînes de caractères pour en faire un seul attribut. Cela peut être
fait soit avec des guillements anglo-saxons (double quotes), soit avec
la commande <command group>.  Par exemple,
<code><foo "Ceci est le 1er attribut"
           <group et le second>></code>
</para>

<note>
Contrairement au HTML, l'apostrophe ne peut pas servir à la place des
guillements.
</note>

<para>
Si des guillements apparaissent dans un argument, ils doivent être
précédés d'une barre oblique inverse (backslash) <value "\\"> afin de ne
pas être interprétés comme le caractère de fin de chaîne de caractères.
<example>
  <set-var texte="Texte avec un guillemet \" dedans">;;;
  <get-var texte>
</example>
</para>

<subsection "Évaluation des commandes">

<para>
Les commandes ont les caractéristiques suivantes:
<list>
<item>le nom de la commande ;
<item>s'il s'agit d'une balise simple ou complexe ;
<item>si les attributs sont développés ou non ;
<item>le type de fonction (primitive ou commande de l'utilisateur) ;
<item>pour les primitives, l'adresse de la routine correspondante dans
le code exécutable, et pour les commandes définies par l'utilisateur, le
texte de remplacement de la commande.
</list>
</para>

<para>
Les caractères sont lus un par un, jusqu'à trouver un <left-angle>.
Le nom de la commande est ensuite lu. Les attributs sont lus, avec ou
sans expansion, selon la caractéristique de la commande. Enfin, si
la commande est complexe, le corps de la balise est lu.
Le texte de remplacement est mis sur la pile, en remplaçaant les mots
commençant par un <value %>, comme <value %body>, <value %attributes>
ainsi que <value %0>, <value %1>, etc.
</para>

<note>
Par défaut, les attributs sont évalués avant la commande elle-même.
</note>

<define-tag text-tt endtag=required whitespace=delete>
<tt>%body</tt>
</define-tag>
<para>
Considérons l'exemple suivant, qui permet de mettre du texte en police
bâton:
<code>
<define-tag text-tt endtag=required whitespace=delete>
<tt>%body</tt>
</define-tag>
</code>
</para>

<para>
Cet exemple a un inconvénient, comme le montre l'exemple ci-dessous:
<example>
<text-tt>Ceci est un <text-tt>essai</text-tt></text-tt>
</example>
Nous souhaiterions que les balises intérieures soient supprimées.
</para>

<set-var _text:tt=0>
<define-tag text-tt endtag=required whitespace=delete>
<increment _text:tt>
<ifeq <get-var _text:tt> 1 "<tt>">
%body
<ifeq <get-var _text:tt> 1 "</tt>">
<decrement _text:tt>
</define-tag>
<para>
L'idée qui vient de suite est d'utiliser une variable pour savoir si
on est déjà à l'intérieur d'une de ces balises:
<code>
<set-var _text:tt=0>
<define-tag text-tt endtag=required whitespace=delete>
<increment _text:tt>
<ifeq <get-var _text:tt> 1 "<tt>">
%body
<ifeq <get-var _text:tt> 1 "</tt>">
<decrement _text:tt>
</define-tag>
</code>
<example>
<text-tt>Ceci est un <text-tt>essai</text-tt></text-tt>
</example>
</para>

<undef opt>
<para>
Mais si nous utilisons des balises simples, comme dans l'exemple
ci-dessous, notre définition ne marche plus parce que les attributs sont
développés avant la commande elle-même:
<example>
<define-tag opt><text-tt>%attributes</text-tt></define-tag>
<opt "Ceci est un <opt essai>">
</example>
</para>

<undef opt>
<para>
Pour remédier à ce problème, il convient donc d'empêcher que les
attributs soient développés en premier. Il convient donc d'écrire:
<example>
<define-tag opt attributes=verbatim><text-tt>%attributes</text-tt></define-tag>
<opt "Ceci est un <opt essai>">
</example>
</para>

<footer>
