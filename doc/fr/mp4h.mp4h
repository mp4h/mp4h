;;;
;;;  mp4h.mp4h -- Documentation pour mp4h
;;;  Copyright 2000, Denis Barbier   <barbier@imacs.polytechnique.fr>
;;;

<set-var package=mp4h>
<set-var version=0.8.0>
<set-var title="MP4H - Un macro processeur pour HTML">

<include <get-var format>.out
    alt=<exit status=1
        message="This file has to be compiled with one of the following lines
   ../../src/mp4h -D format=html mp4h.mp4h -I .. > mp4h.html
   ../../src/mp4h -D format=pod mp4h.mp4h -I .. > mp4h.pod
">
>

<include lang.fr>
<include list-tags>

;;;
;;;   Les caractères pour commentaires sont modifiés
;;;
<set-eol-comment "###">

<header>
<section "Introduction">

<para>
Le programme <mp4h> est un macro-processeur spécialement conçu pour
traiter les documents HTML. Il possède des capacités puissantes de
programmation, avec une syntaxe familière aux auteurs de documents HTML.
</para>

<para>
Ce programme est dérivé de
<URL src="http://www.metahtml.org/" name="<Meta-HTML>">,
écrit par Brian J. Fox,  Il en reprend une partie de l'interface
utilisateur, mais pas le code source.
En effet, <Meta-HTML> était utilisé à l'intérieur du programme <WML>
(<URL src="http://www.engelschall.com/sw/wml/" name="Website Meta Language">)
écrit par Ralf S. Engelschall et que je maintiens depuis janvier 1999.
Pour des raisons de licences, il était difficile de faire des
modifications dans <Meta-HTML>, et j'ai décidé d'écrire mon propre
macro-processeur.
</para>

<para>
Plutôt que de tout réécrire depuis le début, j'ai utilisé en grande
partie le code source de
<URL src="http://www.gnu.org/software/m4/" name="GNU <m4>">,
écrit par René Seindal, en raison de ses nombreux avantages : ce logiciel
est stable, robuste et très bien documenté. Cette version de <mp4h>
s'appuye sur la version 1.4n de GNU <m4>, qui est une version de
développement.
</para>

<para>
Le programme <mp4h> a été conçu dans le seul but de pouvoir définir ses
propres balises dans un document HTML, et n'est en aucune façon un 
éditeur HTML. Ce n'est donc pas la peine de demander d'ajouter des
fonctionnalités pour modifier la mise en page du document final, il y a
peu de chances que je le fasse. Pour avoir un résultat correct, il
suffit d'utiliser un post-processeur comme
<URL src="http://www.w3.org/People/Raggett/tidy/" name="tidy">.
</para>

<section "Options de la ligne de commande">

<para>
Les arguments optionnels sont placés entre crochets. Tous les synonymes
d'une option ont la même syntaxe, donc lorsqu'une option longue accepte
un argument, l'option courte doit l'accepter aussi.
</para>

<para>
La syntaxe générale d'appel de <mp4h> est

<code>mp4h [options] [fichier [fichier] ...]</code>

Les options sont décrites ci-dessous. Si aucun fichier n'est spécifié
sur la ligne de commande, ou s'il a pour nom <file ->, alors les
caractères sont lus sur l'entrée standard.
</para>

<subsection "Mode opératoire">

<option-list>
<option --help>Affiche un message d'aide et quitte le programme</option>
<option --version>Affiche le numéro de version de <mp4h> et quitte le
programme</option>
<option -E --fatal-warnings>Arrête l'exécution du programme dès qu'un
message d'avertissement est affiché</option>
<option -Q --quiet --silent>Supprime certains messages
d'avertissement</option>
</option-list>

<subsection "Pré-processeur">

<option-list>
<option -I --include=<optmand REPERTOIRE>>###
Ajoute ce répertoire à la liste des répertoires où les fichiers à
inclure sont cherchés</option>
<option -D --define=<optmand NOM<optopt =VALEUR>>>###
Affecte une valeur à la variable de nom <var NOM></option>
<option -U --undefine=<optmand COMMANDE>>###
Supprime la primitive de nom <command COMMANDE></option>
</option-list>

<subsection "Limites des ressources">

<option-list>
<option -H --hashsize=<optmand PREMIER>>###
Utilise le nombre premier <optmand PREMIER> pour remplir la table de
hachage (défaut: 509)</option>
<option -L -nesting-limit=<optmand NOMBRE>>###
Fixe la limite arbitraire du nombre d'appels récursifs (défaut: 250)</option>
</option-list>

<subsection "Déboguage">

<option-list>
<option -d --debug=<optmand FLAGS>>###
Détermine quelles sont les informations affichées (voir ci-dessous)</option>
<option -t --trace=<optmand NOM>>###
La commande <command NOM> sera tracée dès qu'elle est définie</option>
<option -l --arglength=<optmand NOMBRE>>###
Limite le nombre de caractères affichés dans les messages de
déboguage</option>
<option -o --error-output=<optmand FICHIER>>###
Redirige dans un fichier les messages de déboguage</option>
</option-list>

<para>
Les drapeaux pour l'option <optmand -d> sont les suivantes:
<option-list>
<option t>###
trace tous les appels de macros, pas seulement
ceux déclarés avec <command debugging-on></option>
<option a>affiche les arguments</option>
<option e>affiche le texte de remplacement</option>
<option c>affiche la commande avant la collecte des arguments, après et
après l'appel de la fonction</option>
<option x>ajoute un identifiant à la sortie, ce qui est utile en cas
d'appel récursif</option>
<option f>affiche le nom du fichier d'entrée</option>
<option l>affiche le numéro de la ligne dans le fichier d'entrée</option>
<option p>affiche le résultat de la recherche de fichiers dans
l'arborescence</option>
<option i>affiche les changements de fichiers d'entrée</option>
<option V>raccourci pour tous ces drapeaux</option>
</option-list>
</para>

<section "Description">

<para>
Le programme <mp4h> est un macro-processeur, ce qui signifie que les
mots-clés définis sont remplacés par un autre texte. Ce chapitre
est un exposé des primitives définies par <mp4h>. Comme <mp4h> a été
spécialement conçu pour les documents HTML, la syntaxe est très proche
de celle du HTML, avec des balises et des attributs. La seule notion
inconnue en HTML est la possibilité de commenter une partie du texte
jusqu'à la fin de la ligne. Les commentaires commencent par trois
point-virgules, par exemple:
<code>;;;  Ceci est un commentaire</code>
</para>

###
###    Définition de nouvelles commandes
###

<subsection "Fonctions pour les définitions">

<para>
La définition de nouvelles commandes est la tâche la plus courante
réalisée par <mp4h>. Comme en HTML, le nom des commandes peut être écrit
indifféremment en monuscules ou majuscules. Dans cette documentation,
seules les minuscules seront utilisées.
Les commandes (aussi appelées balises), sont de deux types : simples ou
complexes. Une balise simple a la forme suivante :
<code><nom [attributs]></code>
tandis qu'une balise complexe est de la forme :
<code><nom [attributs]>
texte
</nom></code>
</para>

<para>
<anchor name="noteattr">
Dans les descriptions de commandes, une barre oblique <slash> indique
que la balise est complexe, et la lettre <command V> que les attributs
de la balise sont lus sans être développés (voir le chapitre sur le
mécanisme de développement des macros pour plus de détails).
</para>

<tag:description define-tag complex>
<var nom>
[attributes=verbatim]
[endtag=required]
[whitespace=delete]
</tag:description>

<para>
Cette fonction permet de définir ses propres commandes. Le premier
argument est le nom de la nouvelle commande. Le texte de remplacement
est le corps de la fonction.

<undef foo>
<example>
<define-tag foo>bar</define-tag>
<foo>
</example>

Même si en HTML les espaces ont en général peu d'importance, il est
utile de comprendre certains points. En particulier,
<code><define-tag foo>bar</define-tag></code>
et
<code><define-tag foo>
bar
</define-tag></code>
ne sont pas équivalents, la deuxième forme comprenant deux sauts de
lignes non présents dans la première.
</para>

<attributes:description>
<attributes:item "whitespace=delete">
Certains espaces sont supprimés dans le texte de remplacement. Il s'agit
des espaces au début ou à la fin de la définition, et des sauts de ligne
qui ne sont pas compris à l'intérieur de commandes délimitées par
<left-angle> et <right-angle>.

<attributes:item "endtag=required">
Définit une balise complexe

<undef foo>
<example>
<define-tag foo>bar</define-tag>
<foo>
</example>

<undef foo>
<example>
<define-tag foo endtag=required>;;;
Le corps est : %body</define-tag>
<foo>Here it is</foo>
</example>

<attributes:item "attributes=verbatim">
Par défaut, les attributs sont évalués avant d'être insérés dans le
texte de remplacement. Lorsque cet attribut est utilisé, les arguments
sont insérés sans développement.

<undef foo bar>
<example>
<define-tag bar>quux</define-tag>
<define-tag foo attributes=verbatim endtag=required>
Corps: %ubody
Attributs: %uattributes
</define-tag>
<foo txt="<bar>">Et voila</foo>
</example>
</attributes:description>

<tag:description provide-tag complex>
<var nom>
[attributes=verbatim]
[endtag=required]
[whitespace=delete]
</tag:description>

<para>
Cette commande est identique à la précédente, sauf qu'aucune opération
n'est effectuée si la commande est déjà définie.
</para>

<tag:description let>
<var nouveau> <var ancien>
</tag:description>

<para>
Copie une fonction dans une autre. Cette fonction permet notamment de
sauvegarder une commande avant de la redéfinir.
</para>

<undef foo bar>
<example>
<define-tag foo>un</define-tag>
<let bar foo>
<define-tag foo>deux</define-tag>
<foo><bar>
</example>

<tag:description undef>
<var nom>
</tag:description>

<para>
Supprime la définition d'une commande.
</para>

<undef foo>
<example>
<define-tag foo>un</define-tag>
<undef foo>
<foo>
</example>

###
###    Opérations sur les variables
###

<subsection "Variables">

<para>
Les variables peuvent être vues comme un cas particulier de fonctions,
qui ne possèdent pas d'arguments. En fait, leur usage est différent,
notamment grâce à la notion de tableaux. En effet, une variable
peut être considérée comme un tableau de caractères séparés par des
sauts de lignes. Comme nous le verrons ci-dessous, cette notion permet
des manipulations qui sont difficilement accessibles avec des fonctions.
</para>

<tag:description set-var>
<var nom>[=<var valeur>]
[<var nom>[=<var valeur>]] ...
</tag:description>

<para>
Cette commande permet de définir des variables.
</para>

<tag:description set-var-verbatim verbatim>
<var nom>[=<var valeur>]
[<var nom>[=<var valeur>]] ...
</tag:description>

<para>
Comme la commande précédente, mais les arguments sont lus tels quels,
sans développement.
</para>

<tag:description get-var>
<var nom>
[<var nom>] ...
</tag:description>

<para>
Affiche le contenu de la variable. Lorsqu'une valeur numérique est
indiquée entre crochets, elle représente un indice (par convention, la
première valeur d'un tableau correspond à un indice 0).
</para>

<example>
<set-var version="0.10.1">
Ceci est la version <get-var version>
</example>

<example>
<set-var foo="0
1
2
3">
<get-var foo[2] foo[0] foo>
</example>

<tag:description get-var-once verbatim>
<var nom>
[<var nom>] ...
</tag:description>

<para>
Comme la commande précédente, mais les arguments ne sont pas développés.
</para>

<undef foo>
<example>
<define-tag foo>0.10.1</define-tag>
<set-var version="<foo>">Ici version <get-var version>
<set-var-verbatim version="<foo>">Ici version <get-var version>
<set-var-verbatim version="<foo>">Ici version <get-var-once version>
</example>

<tag:description preserve>
<var nom>
</tag:description>

<para>
Une pile est utilisée pour sauvegarder le contenu de variables. Cette
commande permet de placer le contenu de la variable dont le nom est
passé en argument dans le sommet de la pile. Après appel de cette
commande, la variable est réinitialisée, c'est-à-dire que son contenu
est vide.
</para>

<tag:description restore>
<var nom>
</tag:description>

<para>
Cette commande effectue l'opération inverse de la commande précédente ;
la variable dont le nom est passé en argument prend la valeur qui se
trouve au sommet de la pile, et cette valeur est supprimée de la pile.
</para>

<tag:description unset-var>
<var nom>
[<var nom>] ...
</tag:description>

<para>
Déclare la variable passée en argument comme n'étant pas définie.
</para>

<tag:description var-exists>
<var nom>
</tag:description>

<para>
Retourne <true> si la variable existe, et rien sinon.
</para>

<tag:description increment>
<var nom>
[by=<var valeur>]
</tag:description>

<para>
Incrémente le contenu de la variable passée en argument. L'incrément par
défaut est 1.
</para>

<attributes:description>
<attributes:item "by=<var valeur>">
Spécifie la valeur de l'incrément.
</attributes:description>

<example>
<set-var i=10>
<get-var i>
<increment i><get-var i>
<increment i by="-3"><get-var i>
</example>

<tag:description decrement>
<var nom>
[by=<var valeur>]
</tag:description>

<para>
Decrémente le contenu de la variable passée en argument, par
défaut de 1.
</para>

<attributes:description>
<attributes:item "by=<var valeur>">
Spécifie la valeur qui est soustraite à la variable
</attributes:description>

<example>
<set-var i=10>
<get-var i>
<decrement i><get-var i>
<decrement i by="3"><get-var i>
</example>

<tag:description copy-var>
<var src>
<var dest>
</tag:description>

<para>
Copie le contenu d'une variable dans une autre.
</para>

<example>
<set-var i=10>
<copy-var i j>
<get-var j>
</example>

<tag:description defvar>
<var nom>
<var valeur>
</tag:description>

<para>
Si la variable n'est pas définie ou est définie comme une chaîne de
caractères vide, affecte la valeur passée en argument. Dans le cas
contraire, aucune opération n'est effectuée.
</para>

<example>
<unset-var title>
<defvar title "Titre"><get-var title>
<defvar title "Nouveau titre"><get-var title>
</example>

<tag:description symbol-info>
<var nom>
</tag:description>

<para>
Affiche des informations sur le symbole passé en argument. S'il s'agit
d'une variable, le mot <command STRING> est affiché, ainsi que le
nombre de lignes de cette variable. S'il s'agit d'une commande ou
primitive, un message indique de quel type de symbole il s'agit :
<command PRIM COMPLEX>, <command PRIM TAG>,
<command USER COMPLEX> et <command USER TAG>
</para>

<unset-var x foo bar symbol-info define-tag>
<example>
<set-var x="0\n1\n2\n3\n4">
<define-tag foo>bar</define-tag>
<define-tag bar endtag=required>;;;
quux</define-tag>
<symbol-info x>
<symbol-info symbol-info>
<symbol-info define-tag>
<symbol-info foo>
<symbol-info bar>
</example>

###
###    Manipulation de chaînes de caractères
###

<subsection "Manipulation de chaînes de caractères">

<tag:description string-length>
<var chaîne>
</tag:description>

<para>
Retourne le nombre de caractères présents dans la chaîne. Les sauts de
ligne comptent pour un caractère.
</para>

<example>
<set-var foo="0
1
2
3">;;;
<string-length <get-var foo>>
<set-var foo="0 1 2 3">;;;
<set-var l=<string-length <get-var foo>>>;;;
<get-var l>
</example>

<tag:description downcase>
<var chaîne>
</tag:description>

<para>
Convertit les caractères en minuscules.
</para>

<example>
<downcase "Qu'en est-il des caractères accentués ?">
</example>

<tag:description upcase>
<var chaîne>
</tag:description>

<para>
Convertit les caractères en majuscules.
</para>

<example>
<upcase "Quid des caractères accentués ?">
</example>

<tag:description capitalize>
<var chaîne>
</tag:description>

<para>
Convertit une phrase en titre anglo-saxon, avec une capitale en début de
chaque mot.
</para>

<example>
<capitalize "Cet éléphant est-il fou ?">
</example>

<tag:description substring>
<var chaîne>
[<var début> [<var fin>]]
</tag:description>

<para>
Extrait une partie de la chaîne de caractères. Le premier argument est
la chaîne à traiter, les deuxième et troisième sont les indices
respectivement du début et de la fin. Par convention, le premier
caractère est représenté par l'indice 0.
</para>

<example>
<set-var foo="abcdefghijk">
<substring <get-var foo> 4>
<substring <get-var foo> 4 6>
</example>

<tag:description subst-in-string>
<var chaîne>
<var regexp>
[<var remplacement>]
[singleline=true]
</tag:description>

<para>
Effectue une substitution dans la chaîne de caractères.
</para>

<example>
<set-var foo="abcdefghijk">
<subst-in-string <get-var foo> "[c-e]">
<subst-in-string <get-var foo> "([c-e])" "\\1 ">
</example>

<attributes:description>
<attributes:item "singleline=true">
Lorsque cet attribut est utilisé, le symbole <command ^> représente le
début de la chaîne et le <command $> la fin de la chaîne. Sinon, ils
représentent respectivement un début de ligne et une fin de ligne.
</attributes:description>

<example>
<set-var foo="abcdefghijk\nabcdefghijk\nabcdefghijk">
<subst-in-string <get-var foo> ".$" "">
<subst-in-string <get-var foo> ".$" "" singleline=true>
</example>

<tag:description subst-in-var>
<var nom>
<var regexp>
[<var remplacement>]
[singleline=true]
</tag:description>

<para>
Effectue une substitution dans une variable.
</para>

<tag:description string-eq>
<var chaîne1>
<var chaîne2>
[caseless=true]
</tag:description>

<para>
Si les arguments 1 et 2  sont identiques, retourne <true>, sinon aucune
valeur n'est affichée.
</para>

<example>
1:<string-eq "aAbBcC" "aabbcc">
2:<string-eq "aAbBcC" "aAbBcC">
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
</attributes:description>

<example>
1:<string-eq "aAbBcC" "aabbcc" caseless=true>
2:<string-eq "aAbBcC" "aAbBcC" caseless=true>
</example>

<tag:description string-neq>
<var chaîne1>
<var chaîne2>
[caseless=true]
</tag:description>

<para>
Si les arguments 1 et 2  sont identiques,
aucune valeur n'est affichée, sinon retourne <true>.
</para>

<example>
1:<string-neq "aAbBcC" "aabbcc">
2:<string-neq "aAbBcC" "aAbBcC">
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
</attributes:description>

<example>
1:<string-neq "aAbBcC" "aabbcc" caseless=true>
2:<string-neq "aAbBcC" "aAbBcC" caseless=true>
</example>

<tag:description string-compare>
<var chaîne1>
<var chaîne2>
[caseless=true]
</tag:description>

<para>
Compare deux chaînes de caractères et retourne une des valeurs less,
greater ou equal suivant que le premier argument est inférieur,
supérieur, ou égal au second.
</para>

<example>
1:<string-compare "aAbBcC" "aabbcc">
2:<string-compare "aAbBcC" "aAbBcC">
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
</attributes:description>

<example>
1:<string-compare "aAbBcC" "aabbcc" caseless=true>
</example>

<tag:description match>
<var chaîne>
<var regexp>
[caseless=true]
[action=report|extract|delete|startpos|endpos|length]
</tag:description>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
<attributes:item "action=report">
Affiche <true> si la chaîne de caractères contient l'expression
régulière, et rien sinon.
<attributes:item "action=extract">
Affiche la partie de la chaîne de caractères qui correspond à l'expression
régulière.
<attributes:item "action=delete">
Affiche la chaîne de caractères en supprimant la portion qui correspond
à l'expression régulière.
<attributes:item "action=startpos">
Si la chaîne de caractères contient l'expression régulière, 
affiche l'indice du premier caractère de la chaîne qui correspond à
l'expression régulière, sinon affiche <value -1>.
<attributes:item "action=endpos">
Si la chaîne de caractères contient l'expression régulière, 
affiche l'indice du dernier caractère de la chaîne qui correspond à
l'expression régulière, sinon affiche <value -1>.
<attributes:item "action=length">
Affiche la longueur de la portion de la chaîne de caractères qui
correspond à l'expression régulière.
</attributes:description>

<example>
1:<match "abcdefghijk" "[c-e]+">
2:<match "abcdefghijk" "[c-e]+" action=extract>
3:<match "abcdefghijk" "[c-e]+" action=delete>
4:<match "abcdefghijk" "[c-e]+" action=startpos>
5:<match "abcdefghijk" "[c-e]+" action=endpos>
6:<match "abcdefghijk" "[c-e]+" action=length>
</example>

<tag:description char-offsets>
<var chaîne>
<var caractère>
[caseless=true]
</tag:description>

<para>
Affiche un tableau contenant les indices où le caractère passé en second
argument apparait dans la chaîne de caractères passée en premier
argument.
</para>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
</attributes:description>

<example>
1:<char-offsets "abcdAbCdaBcD" a>
2:<char-offsets "abcdAbCdaBcD" a caseless=true>
</example>

<tag:description set-regexp-syntax>
[type=basic|extended]
</tag:description>

<para>
Cette commande permet de contrôler quel type d'expression régulière est
utilisé dans les différentes commandes ci-dessus. Actuellement, deux
types sont définis: basic et extended. Le premier correspond aux
expressions régulières de la norme POSIX, le second aux expressions
régulières étendues. Par défaut, les expressions régulières sont de type
extended.
</para>

<example>
<set-var foo="abcdefghijk">
<set-regexp-syntax type=basic>
<subst-in-string <get-var foo> "([c-e]+)" ":\\1:">
<subst-in-string <get-var foo> "\\([c-e]\\{1,\\}\\)" ":\\1:">
<set-regexp-syntax type=extended>
<subst-in-string <get-var foo> "([c-e]+)" ":\\1:">
<subst-in-string <get-var foo> "\\([c-e]\\{1,\\}\\)" ":\\1:">
</example>

<tag:description get-regexp-syntax>
</tag:description>

<para>
Affiche quel est le type d'expressions régulières actuellement utilisé.
</para>

<example>
<get-regexp-syntax>
</example>

###
###    Manipulation de tableaux
###

<subsection "Tableaux">

<para>
Le programme <mp4h> permet de faire simplement des manipulations sur les
tableaux. Le texte contenu à l'intérieur d'une variable peut être vu
indifféremment comme une seule chaîne de caractères, ou comme un tableau
de lignes séparées par des sauts de ligne. Ainsi, après
<code>
<set-var chiffres="0
1
2
3">
</code>
nous pouvons afficher soit le contenu de cette variable, soit une des
lignes.
<set-var chiffres="0\n1\n2\n3">
<example>
<get-var chiffres>
<get-var chiffres[2]>
</example>
</para>

<tag:description array-size>
<var nom>
</tag:description>

<para>
Affiche la taille du tableau dont le nom est passé en argument. Cette
taille est le nombre de lignes présentes dans la variable.
</para>

<example>
<array-size chiffres>
</example>

<tag:description array-append>
<var valeur>
<var nom>
</tag:description>

<para>
Ajoute une ou plusieurs lignes à la fin du tableau.
</para>

<example>
<array-append "10\n11\n12" chiffres>
<get-var chiffres>
</example>

<tag:description array-add-unique>
<var valeur>
<var nom>
[caseless=true]
</tag:description>

<para>
Ajoute une valeur à la fin du tableau si elle n'est pas déjà présente
dans ce tableau.
</para>

<example>
<array-add-unique 2 chiffres>
<get-var chiffres>
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
</attributes:description>

<tag:description array-concat>
<var nom1>
[<var nom2>] ...
</tag:description>

<para>
Concatène le contenu des tableaux dans la variable dont le nom est passé
en premier.
</para>

<example>
<set-var foo="foo">
<set-var bar="bar">
<array-concat foo bar><get-var foo>
</example>

<tag:description array-member>
<var valeur>
<var nom>
[caseless=true]
</tag:description>

<para>
Si la valeur est contenue dans le tableau, retourne l'indice de cette
valeur, sinon retourne <value -1>.
</para>

<example>
<array-member 11 chiffres>
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
</attributes:description>

<tag:description array-shift>
<var offset>
<var nom>
[start=<var début>]
</tag:description>

<para>
Cette commande permet de décaler les éléments du tableau. Le premier
argument est la valeur du décalage, et le second argument le nom de la
variable à manipuler. Si le décalage est négatif, les indices qui
tombent en dessous de 0 sont éliminés, et s'il est positif, les
premières valeurs sont remplies par des lignes vides.
</para>

<example>
<array-shift 2 chiffres>
Maintenant: <get-var chiffres>
<array-shift -4 chiffres>
Et là: <get-var chiffres>
</example>

<attributes:description>
<attributes:item "start=<var début>">
Indique le point de départ à partir duquel le décalage s'opère.
<example>
<array-shift -2 chiffres start=2><get-var chiffres>
</example>
</attributes:description>

<tag:description sort>
<var nom>
[caseless=true]
[numeric=true]
[sortorder=reverse]
</tag:description>

<para>
Trie les lignes d'un tableau par ordre alphabétique.
</para>

<example>
<sort chiffres><get-var chiffres>
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, le tri est fait indépendamment de la casse
des caractères.

<attributes:item "numeric=true">
Effectue un tri en comparant les valeurs numériquement, et non
alphabétiquement.
<example>
<sort chiffres numeric=true><get-var chiffres>
</example>

<attributes:item "sortorder=reverse">
Effectue le tri en ordre inverse
<example>
<sort chiffres numeric=true sortorder=reverse><get-var chiffres>
</example>
</attributes:description>

###
###    Opérateurs arithmétiques
###

<subsection "Opérateurs arithmétiques">

<para>
Les opérateurs suivants permettent de manipuler des nombres. Lorsque
tous les nombres sont des entiers, le résultat est un entier. Dans le
cas contraire, le résultat est un réel.
</para>

<tag:description add>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description substract>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description multiply>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description divide>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description min>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description max>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<example>
<add 1 2 3 4 5 6>
<add 1 2 3 4 5 6.>
</example>

<example>
<define-tag factorielle whitespace=delete>
<ifeq %0 1 1 <multiply %0 <factorielle <substract %0 1>>>>
</define-tag>
<factorielle 6>
</example>

<tag:description modulo>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Contrairement aux fonctions ci-dessus, la fonction modulo ne peut
prendre que deux arguments, qui sont obligatoirement des entiers.
</para>

<example>
<modulo 345 7>
</example>

<para>
Les fonctions suivantes permettent de comparer des nombres, et
retournent <true> lorsque la comparaison est vraie et rien sinon. Si un
des arguments n'est pas un nombre, la comparaison est fausse.
</para>

<tag:description gt>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Retourne <true> si le premier argument est strictement supérieur au
second.
</para>

<tag:description lt>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Retourne <true> si le premier argument est strictement inférieur au
second.
</para>

<tag:description eq>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Retourne <true> si les deux arguments sont égaux.
</para>

<tag:description neq>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Retourne <true> si les deux arguments sont différents.
</para>

###
###    Opérateurs relationnels
###

<subsection "Opérateurs relationnels">

<tag:description not>
<var chaîne>
</tag:description>

<para>
Retourne <true> si la chaîne de caractères est vide, et rien sinon.
</para>

<tag:description and>
<var chaîne>
[<var chaîne>] ...
</tag:description>

<para>
Retourne le dernier argument si tous les arguments sont non vides, sinon
ne retourne rien.
</para>

<tag:description or>
<var chaîne>
[<var chaîne>] ...
</tag:description>

<para>
Affiche le premier argument non nul.
</para>

###
###    Fonctions de contrôle
###

<subsection "Fonctions de contrôle">

<tag:description group verbatim>
<var commande>
[<var commande>] ...
[quoted=true]
</tag:description>

<para>
Cette fonction a pour objectif de grouper une succession de commandes en une
seule. Des applications seront vues dans les exemples des commandes
suivantes.
</para>

<para>
Une autre utilisation de cette commande, moins intuitive mais tout aussi
importante, est de pouvoir mettre des sauts de ligne même si l'attribut
<attribute whitespace=delete> a été spécifié.
</para>

<undef texte1 texte2 texte3>
<example>
<define-tag texte1>
Ce texte est sur
3 lignes sans
whitespace=delete
</define-tag>
<define-tag texte2 whitespace=delete>
Ce texte est sur
3 lignes avec
whitespace=delete
</define-tag>
<define-tag texte3 whitespace=delete>
<group "Ce texte est sur
3 lignes avec
whitespace=delete">
</define-tag>
<texte1>
<texte2>
<texte3>
</example>

<para>
Notez dans l'exemple 2 que les sauts de ligne ont été supprimés, ce qui
a pour conséquence de coller des lettres qui ne doivent pas l'être.
</para>

<attributes:description>
<attributes:item "quoted=true">
Avec cet attribut, le résultat de l'évaluation est entouré de caractères
de contrôle, pour qu'il ne soit plus développé ensuite.
</attributes:description>

<undef foo>
<example>
<subst-in-string "=LT=define-tag foo>bar</define-tag>" "=LT=" "<">
<foo>
<subst-in-string "=LT=define-tag foo>quux</define-tag>" "=LT=" "<group "<" quoted=true>">
<foo>
</example>

<tag:description if verbatim>
<var chaîne>
<var then-clause>
[<var else-clause>]
</tag:description>

<para>
Si la chaîne de caractères passée en premier argument n'est pas vide, le
deuxième argument est exécuté, sinon c'est le troisième.
</para>

<example>
<define-tag test whitespace=delete>
<if %0 "oui" "non">
</define-tag>
<test "chaîne">
<test "">
</example>

<tag:description ifeq verbatim>
<var chaîne1>
<var chaîne2>
<var then-clause>
[<var else-clause>]
</tag:description>

<para>
Si les deux chaînes de caractères passées en premier et deuxième
arguments sont identiques, le troisième argument est exécuté, sinon
c'est le quatrième.
</para>

<tag:description ifneq verbatim>
<var chaîne1>
<var chaîne2>
<var then-clause>
[<var else-clause>]
</tag:description>

<para>
Si les deux chaînes de caractères passées en premier et deuxième
arguments ne sont pas identiques, le troisième argument est exécuté,
sinon c'est le quatrième.
</para>

<tag:description when complex>
<var chaîne>
</tag:description>

<para>
Quand la chaîne de caractères passée en premier argument n'est pas vide,
le corps de cette fonction est exécuté.
</para>

<tag:description while verbatim complex>
<var condition>
</tag:description>

<para>
Tant que la condition passée en premier argument est vérifiée, le corps
de cette fonction est exécuté.
</para>

<example>
<set-var i=10>
<while <gt <get-var i> 0>>;;;
  <get-var i> <decrement i>;;;
</while>
</example>

<tag:description foreach complex>
<var variable>
<var array>
[start=<var début>]
[end=<var fin>]
[step=<var pas>]
</tag:description>

<para>
Cette commande est similaire à la commande <command foreach> de Perl ; 
une variable prend successivement toutes les valeurs stockées dans un
tableau, et le corps de la fonction est exécuté pour chacune de ces
valeurs.

Le premier argument est le nom de la variable qui va prendre les
différentes valeurs, et le deuxième argument est le nom de la variable
qui contient le tableau de valeurs.
</para>

<example>
<set-var x="1\n2\n3\n4\n5\n6">
<foreach i x><get-var i> </foreach>
</example>

<attributes:description>
<attributes:item "start=<var début>">
La boucle commence à l'indice indiqué par cet attribut.
<example>
<set-var x="1\n2\n3\n4\n5\n6">
<foreach i x start=3><get-var i> </foreach>
</example>

<attributes:item "end=<var fin>">
La boucle termine à l'indice indiqué par cet attribut.
<example>
<set-var x="1\n2\n3\n4\n5\n6">
<foreach i x end=3><get-var i> </foreach>
</example>

<attributes:item "step=<var pas>">
Lorsqu'un pas est spécifié, il représente l'incrément de l'index dans la
boucle (1 par défaut).
Si le pas est négatif, la boucle est inversée.
<example>
<set-var x="1\n2\n3\n4\n5\n6">
<foreach i x step=2><get-var i> </foreach>
<foreach i x step=-2><get-var i> </foreach>
</example>
</attributes:description>

<tag:description var-case verbatim>
<var var1>=<var valeur1> <var action1>
[<var var2>=<var valeur2> <var action2> ...
</tag:description>

<para>
Cette commande permet de faire plusieurs tests en une seule instruction.

<example>
<set-var i=0>
<define-tag test whitespace=delete>
<var-case
  x=1   <group <increment i> x<get-var i>>
  x=2   <group <decrement i> x<get-var i>>
  y=1   <group <increment i> y<get-var i>>
  y=2   <group <decrement i> y<get-var i>>
>
</define-tag>
<set-var x=1 y=2><test>
<set-var x=0 y=2><test>
</example>
</para>

<tag:description break>
</tag:description>

<para>
Cette commande fait sortir de la boucle <command while>
la plus interne.
</para>

<example>
<set-var i=10>
<while <gt <get-var i> 0>>;;;
  <get-var i> <decrement i>;;;
  <ifeq <get-var i> 5 <break>>;;;
</while>
</example>

<tag:description warning>
</tag:description>

<para>
Affiche le message donné en arguments sur l'erreur standard.
</para>

<tag:description exit>
[message=<var chaîne>]
[status=<var rc>]
</tag:description>

<para>
Interrompt immédiatement le programme.
</para>

<attributes:description>
<attributes:item "message=<var chaîne>">
Afficher une information sur l'erreur standard, pour indiquer
la cause de l'arrêt du programme.

<attributes:item "status=<var rc>">
Change le code retourné par le programme (-1 par défaut).
</attributes:description>

<tag:description at-end-of-file>
</tag:description>

<para>
Cette commande est spéciale, puisqu'elle stocke ses arguments
temporairement. Ils seront traités lorsque le fichier d'entrée est
entièrement lu.
</para>

###
###    Fonctions sur les fichiers
###

<subsection "Fonctions sur les fichiers">

<tag:description directory-contents>
<var répertoire>
[matching=regexp]
</tag:description>

<para>
Le nom d'un répertoire est passé en argument. Cette commande 
affiche la liste des noms de fichiers présents dans ce répertoire,
séparés par des sauts de ligne.
</para>

<example>
<directory-contents . matching=".*\\.mp4h$">
</example>

<tag:description file-exists>
<var fichier>
</tag:description>

<para>
Affiche <true> si le fichier dont le nom est passé en argument est
trouvé, et rien sinon.
</para>

<tag:description get-file-properties>
<var fichier>
</tag:description>

<para>
Affiche un tableau d'informations sur le fichier dont le nom est donné
en argument. Les informations sont dans l'ordre : la taille du fichier,
son type, la date du dernier changement de l'inode (en secondes depuis
le 1er janvier 1970), la date de la dernière modification du fichier, la
date du dernier accès au fichier, le nom du propriétaire du fichier, et
le nom du groupe.
</para>

<example>
<get-file-properties mp4h.mp4h>
</example>

<tag:description include>
<var fichier>
[alt=<var action>]
[verbatim=true]
</tag:description>

<para>
Lit les données contenues dans le fichier passé en argument.
</para>

<attributes:description>
<attributes:item "alt=<var action>">
Si le fichier n'est pas trouvé, le texte alternatif est affiché. Si cet
attribut est absent et que le fichier n'est pas trouvé, le programme
s'arrête.

<attributes:item "verbatim=true">
Avec cet attribut, le contenu du fichier est inclus sans être modifié
par <mp4h>.
</attributes:description>

<tag:description comment complex>
</tag:description>

<para>
Le corps de cette balise est supprimé.
</para>

<tag:description set-eol-comment>
[<var chaîne>]
</tag:description>

<para>
Permet de modifier les caractères servant de commentaires.
</para>

###
###    Aide au déboguage
###

<subsection "Aide au déboguage">

<para>
Lorsque les constructions deviennent complexes, il peut être ardu de comprendre
ce qui cloche dans ce qu'on a écrit. Les fonctions ci-dessous permettent
d'afficher certaines informations. Le déboguage reste cependant délicat, et est
une partie de <mp4h> à améliorer.
</para>

<tag:description function-def>
<var nom>
</tag:description>

<para>
Affiche le texte de remplacement de la fonction. Par exemple, la commande qui
affiche les exemples à été définie ainsi:
<example>
<function-def example>
</example>
</para>

<tag:description debugmode>
<var chaîne>
</tag:description>

<para>
Cette commande prend le même argument que l'option <optflag d>.
</para>

<tag:description debugfile>
<var fichier>
</tag:description>

<para>
Indique dans quel fichier les instructions de déboguage doivent être
écrites. Si le nom de fichier est vide, l'affichage de ces instructions
se fait de nouveau dans la sortie erreur standard. Si le nom du fichier
est <file ->, l'affichage est supprimé.
</para>

<note>
Il n'existe aucun moyen pour insérer ces instructions à l'intérieur du
document post-traité.
</note>

<tag:description debugging-on>
<var nom>
[<var nom>] ...
</tag:description>

<para>
Les commandes dont les noms sont passés en argument sont «tracées»,
c'est-à-dire que les informations demandées au travers de l'option <optflag d>
ou de la commande <command debugmode> sont affichées lors de chaque appel de
la fonction.
</para>

<tag:description debugging-off>
<var nom>
[<var nom>] ...
</tag:description>

<para>
Fonction inverse de la précédente.
</para>

###
###    Divers
###

<subsection "Divers">

<tag:description __file__>
[<var fichier>]
</tag:description>

<para>
Sans argument, la fonction retourne le nom du fichier en train d'être
traité. S'il y a un argument, il est le nom du fichier retourné par les
prochains appels à cette fonxction.
</para>

<tag:description __line__>
[<var numéro>]
</tag:description>
<para>
Sans argument, la fonction retourne le numéro de la ligne dans le
fichier en train d'être traité. S'il y a un argument, il est le numéro
de la ligne retourné par les prochains appels à cette fonxction.
</para>

<example>
Ceci est le fichier <__file__>, ligne <__line__>.
</example>

<para>
En fait, si vous regardez le fichier source, vous vous apercevrez que le
numéro de la ligne n'est pas correct. En effet, les commandes sont lues
avant d'être développées. Le numéro retourné est le numéro de la
dernière ligne du bloc qui contient cette instrction.
</para>

<tag:description __version__>
</tag:description>

<para>
Affiche le numéro de version de <mp4h>.
</para>

<tag:description date>
[epoch]
</tag:description>

<para>
Affiche l'heure locale correspondant au temps epoch donné en argument.
Lorsqu'il n'y a pas d'argument, l'heure actuelle est affichée.
</para>

<example>
<date>
<set-var info=<get-file-properties <__file__>>>
<date <get-var info[2]>>
</example>

<tag:description timer>
</tag:description>

<para>
Affiche le temps écoulé depuis le précédent appel à cette fonction.
Le temps affiché est le nombre de cycles d'horloge, et est donc
dépendant de la vitesse du processeur.
</para>

<example>
Depuis le début de la compilation de cette documentation par <mp4h>,
voici le nombre de cycles d'horloge écoulés:
<timer>
</example>

<section "Schéma d'expansion des macros">

<para>
Cette partie décrit les mécanismes utilisés pour le remplacement des
macros. Elle se veut aussi précise que possible, aussi n'hésitez pas à
<URL src="mailto:barbier@imacs.polytechnique.fr" name="me signaler">
toute erreur ou omission.
</para>

<subsection "Généralités">

<undef foo bar>
Commençons par donner des exemples de définition de balises:
<example>
<define-tag foo>;;;
Ceci est un exemple de balise simple;;;
</define-tag>;;;
<define-tag bar endtag=required>;;;
Ceci est un exemple de balise complexe;;;
</define-tag>;;;
<foo>
<bar>Corps de la fonction</bar>
</example>

<undef href mail1 mail2 show-attributes show1 show2 bar>
<para>
Les commandes ainsi définies peuvent avoir des attributs, comme toute
balise HTML. Pour que ces attributs se retrouvent dans le texte de
remplacement, les conventions suivantes ont été adoptées:
<list>
<item>Les attributs sont numérotés à partir de 0. Dans le texte de
remplacement, <value %0> sera remplacé par le 1er attribut, <value %1>
par le 2e attribut, etc. Comme le nombre d'attribut n'est pas limité,
les lettres <value %20> seront remplacés par le vingt-et-unième
argument, et pas par le 3e argument suivi d'un 0.
<example>
<define-tag href>;;;
<a href="%0">%1</a>;;;
</define-tag>;;;
<href http://www.gimp.org "The Gimp">
</example>

<item>La séquence <value %#> affiche le nombre d'attributs passés
à la commande.

<item>La séquence <value %%> est remplacée par un <value %>, ce qui est
utile pour des définitions imbriquées.
<example>
<define-tag externe>;;;
Externe, nombre d'attributs: %#
<define-tag interne1>;;;
Interne1, nombre d'attributs: %#;;;
</define-tag>;;;
<define-tag interne2>;;;
Interne2, nombre d'attributs: %%#;;;
</define-tag>;;;
<interne1 %attributes et quelques autres>
<interne2 %attributes et quelques autres>
</define-tag>
<externe liste attributs>
</example>

<item>Les caractères <value %attributes> sont remplacés par la liste 
des arguments, séparés par un espace.
<example>
<define-tag mail1>;;;
<set-var %attributes>;;;
<get-var name>
<get-var mail>
</define-tag>;;;
<set-var name="" mail="">
<mail1 name="Dr. Foo" mail="hello@foo.com">
</example>

<item>Les caractères <value %body> sont remplacés par le corps de la
commande, dans le cas d'une balise complexe.
<example>
<define-tag mail2 endtag=required>;;;
<set-var %attributes>;;;
<a href="mailto:<get-var mail>">%body</a>
</define-tag>;;;
<mail2 mail="hello@foo.com">;;;
<img src="photo.png" alt="Dr. Foo" border=0>;;;
</mail2>
</example>

<item>Les deux formes ci-dessus possèdent une forme alternative, où la
liste est séparée par des sauts de lignes au lieu d'espaces. Il s'agit
des formes <value %Aattributes> et <value %Abody>, le <value A> voulant
dire array (tableau en français).
<example>
<define-tag show-attributes>;;;
<set-var list="%Aattributes" i=0>;;;
<foreach attr list>;;;
%<get-var i>: <get-var attr>
<increment i>;;;
</foreach>;;;
</define-tag>;;;
<show-attributes name="Dr. Foo" mail="hello@foo.com">
</example>

<item>Une autre forme alternative est obtenue en remoplaçant le <value
A> par <value U>, auquel cas le texte est remplacé mais n'est lui-même
pas évalué. Cela n'a de sens que si la commande a été déclarée avec
l'attribut <attribute attributes=verbatim>, parce que dans le cas
contraire les arguments sont développés avant que ces substitutions
n'aient lieu.
<example>
<define-tag show1>;;;
Avant développement: %Uattributes
Après développement: %attributes
</define-tag>;;;
<define-tag show2 attributes=verbatim>;;;
Avant développement: %Uattributes
Après développement: %attributes
</define-tag>;;;
<define-tag bar>et hop %attributes</define-tag>;;;
<show1 <bar la boum>>
<show2 <bar la boum>>
</example>

<item>Les modificateurs <value A> et <value U> peuvent être combinés.
</list>
</para>

<note>
Le mécanisme de lecture des instructions est complètement différent dans
<Meta-HTML> et dans <mp4h>. Avec <Meta-HTML>, il est parfois nécessaire
d'avoir recours à d'autres constructions, comme <value %xbody> et <value
%qbody>. Celles-ci n'ont pas lieu d'être avec <mp4h>, mais pour être au
plus compatible avec <Meta-HTML>, <mp4h> les reconnait aussi et elles
ont exactement le même rôle que <value %body>. Une autre particularité
non mentionnée ci-dessus, qui existe aussi pour des raisons de
compatibilité avec <Meta-HTML>, est le fait que pour des balises
simples, <value %body> est un synonyme de <value %attributes>. Ces
fonctionnalités sont actuellement comprises dans <mp4h>, mais peuvent
très bien être supprimées dans les versions futures.
</note>

<subsection "Attributs">

<para>
Les attributs sont séparés par un ou plusieurs espaces, tabulations ou
sauts de lignes, et chaque attribut doit être une entité complète de
<mp4h>. Par exemple, avec les définitionsa ci-dessus,
<full-command bar> ne peut pas être un attribut,
parce que la commande <full-command bar> est complexe.
En revanche, il est possible d'écrire
<code><foo <foo>></code>
ou même
<code><foo <foo name=src url=ici>></code>
Dans les deux exemples ci-dessus, la commande <command foo> a un seul
attribut.
</para>

<undef foo bar>
<para>
Dans certains cas, il est nécessaire de regrouper ensemble plusieurs
chaînes de caractères pour en faire un seul attribut. Cela peut être
fait soit avec des guillements anglo-saxons (double quotes), soit avec
la commande <command group>.  Par exemple,
<code><foo "Ceci est le 1er attribut"
           <group et le second>></code>
</para>

<note>
Contrairement au HTML, l'apostrophe ne peut pas servir à la place des
guillements.
</note>

<para>
Si des guillements apparaissent dans un argument, ils doivent être
précédés d'une barre oblique inverse (backslash) <value "\\"> afin de ne
pas être interprétés comme le caractère de fin de chaîne de caractères.
<example>
  <set-var texte="Texte avec un guillemet \" dedans">;;;
  <get-var texte>
</example>
</para>

<subsection "Évaluation des commandes">

<para>
Les commandes ont les caractéristiques suivantes:
<list>
<item>le nom de la commande ;
<item>s'il s'agit d'une balise simple ou complexe ;
<item>si les attributs sont développés ou non ;
<item>le type de fonction (primitive ou commande de l'utilisateur) ;
<item>pour les primitives, l'adresse de la routine correspondante dans
le code exécutable, et pour les commandes définies par l'utilisateur, le
texte de remplacement de la commande.
</list>
</para>

<para>
Les caractères sont lus un par un, jusqu'à trouver un <left-angle>.
Le nom de la commande est ensuite lu. Les attributs sont lus, avec ou
sans expansion, selon la caractéristique de la commande. Enfin, si
la commande est complexe, le corps de la balise est lu.
Le texte de remplacement est mis sur la pile, en remplaçaant les mots
commençant par un <value %>, comme <value %body>, <value %attributes>
ainsi que <value %0>, <value %1>, etc.
</para>

<note>
Par défaut, les attributs sont évalués avant la commande elle-même.
</note>

<define-tag text-tt endtag=required whitespace=delete>
<tt>%body</tt>
</define-tag>
<para>
Considérons l'exemple suivant, qui permet de mettre du texte en police
bâton:
<code>
<define-tag text-tt endtag=required whitespace=delete>
<tt>%body</tt>
</define-tag>
</code>
</para>

<para>
Cet exemple a un inconvénient, comme le montre l'exemple ci-dessous:
<example>
<text-tt>Ceci est un <text-tt>essai</text-tt></text-tt>
</example>
Nous souhaiterions que les balises intérieures soient supprimées.
</para>

<set-var _text:tt=0>
<define-tag text-tt endtag=required whitespace=delete>
<increment _text:tt>
<ifeq <get-var _text:tt> 1 "<tt>">
%body
<ifeq <get-var _text:tt> 1 "</tt>">
<decrement _text:tt>
</define-tag>
<para>
L'idée qui vient de suite est d'utiliser une variable pour savoir si
on est déjà à l'intérieur d'une de ces balises:
<code>
<set-var _text:tt=0>
<define-tag text-tt endtag=required whitespace=delete>
<increment _text:tt>
<ifeq <get-var _text:tt> 1 "<tt>">
%body
<ifeq <get-var _text:tt> 1 "</tt>">
<decrement _text:tt>
</define-tag>
</code>
<example>
<text-tt>Ceci est un <text-tt>essai</text-tt></text-tt>
</example>
</para>

<undef opt>
<para>
Mais si nous utilisons des balises simples, comme dans l'exemple
ci-dessous, notre définition ne marche plus parce que les attributs sont
développés avant la commande elle-même:
<example>
<define-tag opt><text-tt>%attributes</text-tt></define-tag>
<opt "Ceci est un <opt essai>">
</example>
</para>

<undef opt>
<para>
Pour remédier à ce problème, il convient donc d'empêcher que les
attributs soient développés en premier. Il convient donc d'écrire:
<example>
<define-tag opt attributes=verbatim><text-tt>%attributes</text-tt></define-tag>
<opt "Ceci est un <opt essai>">
</example>
</para>

<section "Auteur">
<para>
Denis Barbier
<URL src="mailto:barbier@imacs.polytechnique.fr"
     name="<left-angle>barbier@imacs.polytechnique.fr<right-angle>">
</para>


<section "Remerciement">
<para>
Je tiens à remercier très sincèrement Brian J. Fox pour avoir écrit
<Meta-HTML> et René Seindal pour son travail sur ce merveilleux
macro-processeur qu'est GNU <m4>.
</para>

<footer>
