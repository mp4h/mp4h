;;;
;;;  mp4h.mp4h -- Documentation for mp4h
;;;  Copyright 2000, Denis Barbier   <barbier@imacs.polytechnique.fr>
;;;

<include "version">

<if <not <get-var format>>
  <exit status=1
        message="This file has to be compiled with one of the following lines
   ../../src/mp4h -D format=html mp4h.mp4h > mp4h.html
   ../../src/mp4h -D format=pod mp4h.mp4h > mp4h.pod
">>

<include <get-var format>.out>
<include tags>

<header>
<section "Description">

<para>
Le programme <mp4h> est un macro-processeur spécialement conçu pour
traiter les documents HTMl. Il possède des capacités puissantes de
programmation, avec une syntaxe familière aux auteurs de documents HTML.
</para>

<para>
Ce programme est un clone de
<URL src="http://www.metahtml.org/" name="<Meta-HTML>">, écrit par Brian
J. Fox,  Il en reprend
une partie de l'interface utilisateur, mais pas le code source.
En effet, <Meta-HTML> était utilisé à l'intérieur du programme
<WML> (<URL src="http://www.engelschall.com/sw/wml/" name="Website Meta Language">)
écrit par Ralf S. Engelschall et que je maintiens depuis février 1998.
Pour des raisons de licences, il était difficile de faire des
modifications dans <Meta-HTML>, et j'ai décidé d'écrire mon propre
macro-processeur.
</para>

<para>
Plutôt que de tout réécrire depuis le début, j'ai utilisé en grande
partie le code source de <URL src="http://www.gnu.org/software/m4/" name="GNU <m4>">,
écrit par René Seindal, à cause de ses nombreux avantages : ce logiciel
est stable, robuste et très bien documenté. Cette version de <mp4h>
s'appuye sur la version 1.4n de GNU <m4>, qui est une version de
développement.
</para>

<section "Commandes">

<para>
Le programme <mp4h> est un macro-processeur, ce qui signifie que les
mots-clés définis sont remplacés par un autre texte. Dans ce chapitre
est vu l'ensemble des commandes définies par <mp4h>.
</para>

;;;
;;;    Definition of new macros
;;;

<subsection "Fonctions pour les définitions">

<para>
La définition de nouvelles commandes est la tâche la plus courante
réalisée par <mp4h>. Comme <mp4h> a été spécialement conçu pour les
documents HTML, la syntaxe est très proche de celle du HTML. Les
commandes (aussi appelées balises), sont de deux types : simples ou
complexes. Une balise simple a la forme suivante :
<code><nom [attributs]></code>
tandis qu'une balise complexe est de la forme :
<code><nom [attributs]>
texte
</nom></code>
</para>

<tag:description define-tag complex>
<var nom>
[attributes=verbatim]
[endtag=required]
[whitespace=delete]
</tag:description>

<para>
Cette fonction permet de définir ses propres commandes. Le premier
argument est le nom de la nouvelle commande. Le texte de remplacement
est le corps de la fonction.

<undef foo>
<example>
<define-tag foo>bar</define-tag>;;;
<foo>
</example>

Même si en HTML les espaces ont en général peu d'importance, il est
utile de comprendre certains points. En particulier,
<code><define-tag foo>bar</define-tag></code>
et
<code><define-tag foo>
bar
</define-tag></code>
ne sont pas équivalents, la deuxième forme comprenant deux sauts de
lignes non présents dans la première.
</para>

<attributes:description>
<attributes:item "whitespace=delete">
Certains espaces sont supprimés dans le texte de remplacement. Il s'agit
des espaces au début ou à la fin de la définition, et des sauts de ligne
qui ne sont pas compris à l'intérieur de commandes délimitées par
<left-angle> et <right-angle>.

<attributes:item "endtag=required">
Définit une balise complexe

<undef foo>
<example>
<define-tag foo>bar</define-tag>;;;
<foo>
</example>

<undef foo>
<example>
<define-tag foo endtag=required>body is: %body</define-tag>;;;
<foo>Here it is</foo>
</example>

<attributes:item "attributes=verbatim">
Par défaut, les attributs sont évalués lors de l'appel de la fonction.
Lorsque cet attribut est utilisé, les arguments ne sont pas évalués.

<undef foo bar>
<example>
<define-tag bar>quux</define-tag>;;;
<define-tag foo attributes=verbatim endtag=required>Corps: %ubody
Attributs: %uattributes
</define-tag>;;;
<foo txt="<bar>">Et voila</foo>
</example>
</attributes:description>

<tag:description provide-tag complex>
<var nom>
[attributes=verbatim]
[endtag=required]
[whitespace=delete]
</tag:description>

<para>
Cette commande est identique à la précédente, sauf qu'aucune opération
n'est effectuée si la commande est déjà définie.
</para>

<tag:description let>
<var new> <var old>
</tag:description>

<para>
Copie une fonction dans une autre. Cette fonction permet notamment de
sauvegarder une fonction avant de la redéfinir.
</para>

<undef foo bar>
<example>
<define-tag foo>un</define-tag>;;;
<let bar foo>;;;
<define-tag foo>deux</define-tag>;;;
<foo><bar>
</example>

<tag:description undef>
<var nom>
</tag:description>

<para>
Supprime la définition d'une commande.
</para>

<undef foo>
<example>
<define-tag foo>un</define-tag>;;;
<undef foo>;;;
<foo>
</example>

;;;
;;;    Variable functions
;;;

<subsection "Variables">

<para>
Les variables peuvent être vues comme un cas particulier de fonctions,
qui ne possèdent pas d'arguments. En fait, leur usage est différent,
notamment grâce à la notion de tableaux. En effet, une variable
peut être considérée comme un tableau de caractères séparés par des
sauts de lignes. Comme nous le verrons ci-dessous, cette notion permet
des manipulations qui sont difficilement accessibles avec des fonctions.
</para>

<tag:description set-var>
<var nom>=<var valeur>
[<var nom>=<var valeur>] ...
</tag:description>

<para>
Cette commande permet de définir des variables.
</para>

<tag:description set-var-verbatim verbatim>
<var nom>=<var valeur>
[<var nom>=<var valeur>] ...
</tag:description>

<para>
Comme la commande précédente, mais les arguments sont lus tels quels,
sans développement.
</para>

<tag:description get-var>
<var nom>
[<var nom>] ...
</tag:description>

<para>
Affiche le contenu de la variable. Lorsqu'une valeur numérique est
indiquée entre crochets, elle représente un indice (par convention, la
première valeur d'un tableau correspond à un indice 0).
</para>

<example>
<set-var version="0.10.1">;;;
Ceci est la version <get-var version>
</example>

<example>
<set-var foo="0
1
2
3">;;;
<get-var foo[2] foo[0] foo>
</example>

<tag:description get-var-once verbatim>
<var nom>
[<var nom>] ...
</tag:description>

<para>
Comme la commande précédente, mais les arguments ne sont pas développés.
</para>

<undef foo>
<example>
<define-tag foo>0.10.1</define-tag>;;;
<set-var version="<foo>">Ici version <get-var version>
<set-var-verbatim version="<foo>">Ici version <get-var version>
<set-var-verbatim version="<foo>">Ici version <get-var-once version>
</example>

<tag:description preserve>
<var nom>
</tag:description>

<para>
Une pile est utilisée pour sauvegarder le contenu de variables. Cette
commande permet de placer le contenu de la variable dont le nom est
passé en argument dans le sommet de la pile.
</para>

<tag:description restore>
<var nom>
</tag:description>

<para>
Cette commande effectue l'opération inverse de la commande précédente ;
la variable dont le nom est passé en argument prend la valeur qui se
trouve au sommet de la pile, et cette valeur est supprimée de la pile.
</para>

<tag:description unset-var>
<var nom>
[<var nom>] ...
</tag:description>

<para>
Déclare la variable passée en argument comme n'étant pas définie.
</para>

<tag:description var-exists>
<var nom>
</tag:description>

<para>
Retourne <true> si la variable existe, et rien sinon.
</para>

<tag:description increment>
<var nom>
[amount=<var valeur>]
</tag:description>

<para>
Incrémente le contenu de la variable passée en argument. L'incrément par
défaut est 1.
</para>

<attributes:description>
<attributes:item "amount=<var valeur>">
Spécifie la valeur de l'incrément.
</attributes:description>

<example>
<set-var i=10>;;;
<get-var i>
<increment i><get-var i>
<increment i amount="-3"><get-var i>
</example>

<tag:description decrement>
<var nom>
[amount=<var valeur>]
</tag:description>

<para>
Decrémente le contenu de la variable passée en argument, par
défaut de 1.
</para>

<attributes:description>
<attributes:item "amount=<var valeur>">
Spécifie la valeur qui est soustraite à la variable
</attributes:description>

<example>
<set-var i=10>;;;
<get-var i>
<decrement i><get-var i>
<decrement i amount="3"><get-var i>
</example>

<tag:description copy-var>
<var src>
<var dest>
</tag:description>

<para>
Copie le contenu d'une variable dans une autre.
</para>

<example>
<set-var i=10>;;;
<copy-var i j>;;;
<get-var j>
</example>

<tag:description defvar>
<var nom>
<var valeur>
</tag:description>

<para>
Si la variable n'est pas définie ou est définie comme une chaîne de
caractères vide, affecte la valeur passée en argument. Dans le cas
contraire, aucune opération n'est effectuée.
</para>

<example>
<unset-var title>;;;
<defvar title "Titre"><get-var title>
<defvar title "Nouveau titre"><get-var title>
</example>

<tag:description symbol-info>
<var nom>
</tag:description>

<para>
Affiche des informations sur le symbole passé en argument. S'il s'agit
d'une variable, le mot <code>STRING</code> est affiché, ainsi que le
nombre de lignes de cette variable. S'il s'agit d'une commande ou
primitive, un message indique de quel type de symbole il s'agit :
<code>PRIM COMPLEX</code>, <code>PRIM TAG</code>,
<code>USER COMPLEX</code> et <code>USER TAG</code>
</para>

<example>
<set-var x="0\n1\n2\n3\n4">;;;
<define-tag foo>bar</define-tag>;;;
<define-tag bar endtag=required>quux</define-tag>;;;
<symbol-info x>
<symbol-info symbol-info>
<symbol-info define-tag>
<symbol-info foo>
<symbol-info bar>
</example>

;;;
;;;    String functions
;;;

<subsection "Manipulation de chaînes de caractères">

<tag:description string-length>
<var string>
</tag:description>

<para>
Retourne le nombre de caractères présents dans la chaîne. Les sauts de
ligne comptent pour un caractère.
</para>

<example>
<set-var foo="0
1
2
3">;;;
<string-length <get-var foo>>
<set-var foo="0 1 2 3">;;;
<set-var l=<string-length <get-var foo>>>;;;
<get-var l>
</example>

<tag:description downcase>
<var string>
</tag:description>

<para>
Convertit les caractères en minuscules.
</para>

<example>
<downcase "Qu'en est-il des caractères accentués ?">
</example>

<tag:description upcase>
<var string>
</tag:description>

<para>
Convertit les caractères en majuscules.
</para>

<example>
<upcase "Qu'en est-il des caractères accentués ?">
</example>

<tag:description substring>
<var string>
[<var start> [<var end>]]
</tag:description>

<para>
Extrait une partie de la chaîne de caractères. Le premier argument est
la chaîne à traiter, les deuxième et troisième sont les indices
respectivement du début et de la fin. Par convention, le premier
caractère est représenté par l'indice 0.
</para>

<example>
<set-var foo="abcdefghijk">;;;
<substring <get-var foo> 4>
<substring <get-var foo> 4 6>
</example>

<tag:description subst-in-string>
<var string>
<var regexp>
[<var replacement>]
[singleline=true]
</tag:description>

<para>
Effectue une substitution dans la chaîne de caractères.
</para>

<example>
<set-var foo="abcdefghijk">;;;
<subst-in-string <get-var foo> "[c-e]">
<subst-in-string <get-var foo> "([c-e])" "\\1 ">
</example>

<example>
<set-var foo="abcdefghijk\nabcdefghijk\nabcdefghijk">;;;
<subst-in-string <get-var foo> ".$" "">
<subst-in-string <get-var foo> ".$" "" singleline=true>
</example>

<tag:description subst-in-var>
<var nom>
<var regexp>
[<var replacement>]
[singleline=true]
</tag:description>

<para>
Effectue une substitution dans une variable.
</para>

<tag:description string-eq>
<var string1>
<var string2>
[caseless=true]
</tag:description>

<para>
Si les arguments 1 et 2  sont identiques, retourne <true>, sinon aucune
valeur n'est affichée.
</para>

<example>
1:<string-eq "aAbBcC" "aabbcc">
2:<string-eq "aAbBcC" "aAbBcC">
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
</attributes:description>

<example>
1:<string-eq "aAbBcC" "aabbcc" caseless=true>
2:<string-eq "aAbBcC" "aAbBcC" caseless=true>
</example>

<tag:description string-neq>
<var string1>
<var string2>
[caseless=true]
</tag:description>

<para>
Si les arguments 1 et 2  sont identiques,
aucune valeur n'est affichée, sinon retourne <true>.
</para>

<example>
1:<string-neq "aAbBcC" "aabbcc">
2:<string-neq "aAbBcC" "aAbBcC">
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
</attributes:description>

<example>
1:<string-neq "aAbBcC" "aabbcc" caseless=true>
2:<string-neq "aAbBcC" "aAbBcC" caseless=true>
</example>

<tag:description string-compare>
<var string1>
<var string2>
[caseless=true]
</tag:description>

<para>
Compare deux chaînes de caractères et retourne une des valeurs less,
greater ou equal suivant que le premier argument est inférieur,
supérieur, ou égal au second.
</para>

<example>
1:<string-compare "aAbBcC" "aabbcc">
2:<string-compare "aAbBcC" "aAbBcC">
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
</attributes:description>

<example>
1:<string-compare "aAbBcC" "aabbcc" caseless=true>
</example>

<tag:description match>
<var string>
<var regexp>
[caseless=true]
[action=report|extract|delete|startpos|endpos|length]
</tag:description>

<para>
Compare deux chaînes de caractères et retourne une des valeurs <value
less>, <value greater> ou <value equal> suivant que le premier argument
est inférieur, supérieur, ou égal au second.
</para>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
<attributes:item "action=report">
Affiche <true> si la chaîne de caractères contient l'expression
régulière, et rien sinon.
<attributes:item "action=extract">
Affiche la partie de la chaîne de caractères qui correspond à l'expression
régulière.
<attributes:item "action=delete">
Affiche la chaîne de caractères en supprimant la portion qui correspond
à l'expression régulière.
<attributes:item "action=startpos">
Si la chaîne de caractères contient l'expression régulière, 
affiche l'indice du premier caractère de la chaîne qui correspond à
l'expression régulière, sinon affiche <value -1>.
<attributes:item "action=endpos">
Si la chaîne de caractères contient l'expression régulière, 
affiche l'indice du dernier caractère de la chaîne qui correspond à
l'expression régulière, sinon affiche <value -1>.
<attributes:item "action=length">
Affiche la longueur de la portion de la chaîne de caractères qui
correspond à l'expression régulière.
</attributes:description>

<example>
1:<match "abcdefghijk" "[c-e]+">
2:<match "abcdefghijk" "[c-e]+" action=extract>
3:<match "abcdefghijk" "[c-e]+" action=delete>
4:<match "abcdefghijk" "[c-e]+" action=startpos>
5:<match "abcdefghijk" "[c-e]+" action=endpos>
6:<match "abcdefghijk" "[c-e]+" action=length>
</example>

<tag:description char-offsets>
<var string>
<var character>
[caseless=true]
</tag:description>

<para>
Affiche un tableau contenant les indices où le caractère passé en second
argument apparait dans la chaîne de caractères passée en premier
argument.
</para>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
</attributes:description>

<example>
1:<char-offsets "abcdAbCdaBcD" a>
2:<char-offsets "abcdAbCdaBcD" a caseless=true>
</example>

<tag:description set-regexp-syntax>
[type=basic|extended]
</tag:description>

<para>
Cette commande permet de contrôler quel type d'expression régulière est
utilisé dans les différentes commandes ci-dessus. Actuellement, deux
types sont définis: basic et extended. Le premier correspond aux
expressions régulières de la norme POSIX, le second aux expressions
régulières étendues. Par défaut, les expressions régulières sont de type
extended.
</para>

<example>
<set-var foo="abcdefghijk">;;;
<set-regexp-syntax type=basic>;;;
<subst-in-string <get-var foo> "([c-e]+)" ":\\1:">
<subst-in-string <get-var foo> "\\([c-e]\\{1,\\}\\)" ":\\1:">
<set-regexp-syntax type=extended>;;;
<subst-in-string <get-var foo> "([c-e]+)" ":\\1:">
<subst-in-string <get-var foo> "\\([c-e]\\{1,\\}\\)" ":\\1:">
</example>

<tag:description get-regexp-syntax>
</tag:description>

<para>
Affiche quel est le type d'expressions régulières actuellement utilisé.
</para>

<example>
<get-regexp-syntax>
</example>

;;;
;;;    Array functions
;;;

<subsection "Tableaux">

<para>
Le programme <mp4h> permet de faire des manipulations simples sur les
tableaux. Le texte contenu à l'intérieur d'une variable peut être vu
indifféremment comme une seule chaîne de caractères, ou comme un tableau
de lignes séparées par des sauts de ligne. Ainsi, après
<code>
<set-var chiffres="0
1
2
3">
</code>
nous pouvons afficher soit le contenu de cette variable, soit une des
lignes.
<set-var chiffres="0\n1\n2\n3">;;;
<example>
<get-var chiffres[2]>
<get-var chiffres>
</example>
</para>

<tag:description array-size>
<var nom>
</tag:description>

<para>
Affiche la taille du tableau dont le nom est passé en argument. Cette
taille est le nombre de lignes présentes dans la variable.
</para>

<example>
<array-size chiffres>
</example>

<tag:description array-append>
<var valeur>
<var nom>
</tag:description>

<para>
Ajoute une ou plusieurs lignes à la fin du tableau.
</para>

<example>
<array-append "10\n11\n12" chiffres>;;;
<get-var chiffres>
</example>

<tag:description array-add-unique>
<var valeur>
<var nom>
[caseless=true]
</tag:description>

<para>
Ajoute une valeur à la fin du tableau si elle n'est pas déjà présente
dans ce tableau.
</para>

<example>
<array-add-unique 2 chiffres>;;;
<get-var chiffres>
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
</attributes:description>

<tag:description array-concat>
<var nom1>
[<var nom2>] ...
</tag:description>

<para>
Concatène le contenu des tableaux dans la variable dont le nom est passé
en premier.
</para>

<example>
<set-var foo="foo">;;;
<set-var bar="bar">;;;
<array-concat foo bar><get-var foo>
</example>

<tag:description array-member>
<var valeur>
<var nom>
[caseless=true]
</tag:description>

<para>
Si la valeur est contenue dans le tableau, retourne l'indice de cette
valeur, sinon retourne <value -1>.
dans ce tableau.
</para>

<example>
<array-member 11 chiffres>
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, la comparaison est faite indépendamment de la casse
des caractères.
</attributes:description>

<tag:description array-shift>
<var offset>
<var nom>
[start=<var début>]
</tag:description>

<para>
Cette commande permet de décaler les éléments du tableau. Le premier
argument est la valeur du décalage, et le second argument le nom de la
variable à manipuler. Si le décalage est négatif, les indices qui
tombent en dessous de 0 sont éliminés, et s'il est positif, les
premières valeurs sont remplies par des lignes vides.
</para>

<example>
<array-shift 2 chiffres>;;;
Maintenant: <get-var chiffres>
<array-shift -4 chiffres>;;;
Et là: <get-var chiffres>
</example>

<attributes:description>
<attributes:item "start=<var début>">
Indique le point de départ à partir duquel le décalage s'opère.
<example>
<array-shift 2 chiffres start=2><get-var chiffres>
</example>
</attributes:description>

<tag:description sort>
<var nom>
[caseless=true]
[numeric=true]
[sortorder=reverse]
</tag:description>

<para>
Trie les lignes d'un tableau par ordre alphabétique.
</para>

<example>
<sort chiffres><get-var chiffres>
</example>

<attributes:description>
<attributes:item "caseless=true">
Avec cet attribut, le tri est fait indépendamment de la casse
des caractères.

<attributes:item "numeric=true">
Effectue un tri en comparant les valeurs numériquement, et non
alphabétiquement.
<example>
<sort chiffres numeric=true><get-var chiffres>
</example>

<attributes:item "sortorder=reverse">
Effectue le tri en ordre inverse
<example>
<sort chiffres numeric=true sortorder=reverse><get-var chiffres>
</example>
</attributes:description>

;;;
;;;    Numerical operators
;;;

<subsection "Opérateurs arithmétiques">

<para>
Les opérateurs suivants permettent de manipuler des nombres. Lorsque
tous les nombres sont des entiers, le résultat est un entier. Dans le
cas contraire, le résultat est un réel.
</para>

<tag:description add>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description substract>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description multiply>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description divide>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description min>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<tag:description max>
<var nombre1>
<var nombre2>
[<var nombre3>] ...
</tag:description>

<example>
<add 1 2 3 4 5 6>
<add 1 2 3 4 5 6.>
</example>

<example>
<define-tag factorielle whitespace=delete>
<ifeq %0 1 1 <multiply %0 <factorielle <substract %0 1>>>>
</define-tag>
<factorielle 6>
</example>

<tag:description modulo>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Contrairement aux fonctions ci-dessus, la fonction modulo ne peut
prendre que deux arguments, qui sont obligatoirement des entiers.
</para>

<example>
<modulo 345 7>
<factorielle 6>
</example>

<para>
Les fonctions suivantes permettent de comparer des nombres, et
retournent <true> lorsque la comparaison est vraie et rien sinon. Si un
des arguments n'est pas un nombre, la comparaison est fausse.
</para>

<tag:description gt>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Retourne <true> si le premier argument est strictement supérieur au
second.
</para>

<tag:description lt>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Retourne <true> si le premier argument est strictement inférieur au
second.
</para>

<tag:description eq>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Retourne <true> si les deux arguments sont égaux.
</para>

<tag:description neq>
<var nombre1>
<var nombre2>
</tag:description>

<para>
Retourne <true> si les deux arguments sont différents.
</para>

;;;
;;;    Relational operators
;;;

<subsection "Operateurs relationnels">

<tag:description not>
<var string>
</tag:description>

<para>
Retourne <true> si la chaîne de caractères est vide, et rien sinon.
</para>

<tag:description and>
<var string>
[<var string>] ...
</tag:description>

<para>
Retourne le dernier argument si tous les arguments sont non vides, sinon
ne retourne rien.
</para>

<tag:description or>
<var string>
[<var string>] ...
</tag:description>

<para>
Affiche le premier argument non nul.
</para>

;;;
;;;    Flow functions
;;;

<subsection "Fonctions de contrôle">

<tag:description group verbatim>
<var statement>
[<var statement>] ...
</tag:description>

<para>
Cette fonction a pour objectif de grouper une succession de commandes en une
seule. Des applications seront vues dans les exemples des commandes
suivantes.
</para>

<para>
Une autre utilisation de cette commande, moins intuitive mais tout aussi
importante, est de pouvoir mettre des sauts de ligne même si l'attribut
<attribute whitespace=delete> a été spécifié.
</para>

<example>
<define-tag texte1>
Ce texte est sur
3 lignes sans
whitespace=delete
</define-tag >
<define-tag texte2 whitespace=delete>
Ce texte est sur
3 lignes avec
whitespace=delete
</define-tag >
<define-tag texte3 whitespace=delete>
<group "Ce texte est sur
3 lignes avec
whitespace=delete">
</define-tag >
<texte1>
<texte2>
<texte3>
</example>

<para>
Notez dans l'exemple 2 que les sauts de ligne ont été supprimés, ce qui
a pour conséquence de coller des lettres qui ne doivent pas l'être.
</para>

<tag:description if verbatim>
<var string>
<var then-clause>
[<var else-clause>]
</tag:description>

<para>
Si la chaîne de caractères passée en premier argument n'est pas vide, le
deuxième argument est exécuté, sinon c'est le troisième.
</para>

<example>
<define-tag test whitespace=delete>
<if %0 "oui" "non">
</define-tag>
<test "chaine">
<test "">
</example>

<tag:description ifeq verbatim>
<var string1>
<var string2>
<var then-clause>
[<var else-clause>]
</tag:description>

<para>
Si les deux chaînes de caractères passées en premier et deuxième
arguments sont identiques, le troisième argument est exécuté, sinon
c'est le quatrième.
</para>

<tag:description ifneq verbatim>
<var string1>
<var string2>
<var then-clause>
[<var else-clause>]
</tag:description>

<para>
Si les deux chaînes de caractères passées en premier et deuxième
arguments ne sont pas identiques, le troisième argument est exécuté,
sinon c'est le quatrième.
</para>

<tag:description when complex>
<var string>
</tag:description>

<para>
Quand la chaîne de caractères passée en premier argument n'est pas vide,
le corps de cette fonction est exécuté.
</para>

<tag:description while verbatim complex>
<var cond>
</tag:description>

<para>
Tant que la condition passée en premier argument est vérifiée, le corps
de cette fonction est exécuté.
</para>

<example>
<set-var i=10>
<while <gt <get-var i> 0>>;;;
  <get-var i> <decrement i>;;;
</while>
</example>

<tag:description foreach complex>
<var variable>
<var array>
[start=<var start>]
[end=<var end>]
[step=<var pas>]
</tag:description>

<para>
Cette commande est similaire à la commande <code>foreach</code> de Perl ; 
une variable prend successivement toutes les valeurs stockées dans un
tableau, et le corps de la fonction est exécuté pour chacune de ces
valeurs.

Le premier argument est le nom de la variable qui va prendre les
différentes valeurs, et le deuxième argument est le nom de la variable
qui contient le tableau de valeurs.
</para>

<example>
<set-var x="1\n2\n3\n4\n5\n6">
<foreach i x><get-var i> </foreach>
</example>

<attributes:description>
<attributes:item "start=<var start>">
La boucle commence à l'indice indiqué par cet attribut.
<example>
<set-var x="1\n2\n3\n4\n5\n6">
<foreach i x start=3><get-var i> </foreach>
</example>

<attributes:item "end=<var end>">
La boucle termine à l'indice indiqué par cet attribut.
<example>
<set-var x="1\n2\n3\n4\n5\n6">
<foreach i x end=3><get-var i> </foreach>
</example>

<attributes:item "step=<var pas>">
Lorsqu'un pas est spécifié, 
Au lieu de prendre toutes les valeurs du tableau, 
Si le pas est négatif, la boucle est inversée.
<example>
<set-var x="1\n2\n3\n4\n5\n6">
<foreach i x step=2><get-var i> </foreach>
<foreach i x step=-2><get-var i> </foreach>
</example>
</attributes:description>

<tag:description var-case verbatim>
<var var1>=<var valeur1> <var action1>
[<var var2>=<var valeur2> <var action2> ...
</tag:description>

<para>
Cette commande permet de faire plusieurs tests en une seule instruction.

<example>
<set-var i=0>
<define-tag test whitespace=delete>
<var-case
  x=1   <group <increment i> x<get-var i>>
  x=2   <group <decrement i> x<get-var i>>
  y=1   <group <increment i> y<get-var i>>
  y=2   <group <decrement i> y<get-var i>>
>
</define-tag>
<set-var x=1 y=2><test>
<set-var x=0 y=2><test>
</example>
</para>

<tag:description break>
</tag:description>

<para>
Cette commande fait sortir de la boucle <code>while</code>
la plus interne.
</para>

<example>
<set-var i=10>
<while <gt <get-var i> 0>>;;;
  <get-var i> <decrement i>;;;
  <ifeq <get-var i> 5 <break>>;;;
</while>
</example>

;;;
;;;    File functions
;;;

<subsection "Fonctions sur les fichiers">

<tag:description directory-contents>
<var dirname>
[matching=regexp]
</tag:description>

<para>
Le nom d'un répertoire est passé en argument. Cette commande 
affiche la liste des noms de fichiers présents dans ce répertoire,
séparés par des sauts de ligne.
</para>

<example>
<directory-contents . matching=".*\\.mp4h$">
</example>

<tag:description file-exists>
<var filename>
</tag:description>

<para>
Affiche <true> si le fichier dont le nom est passé en argument est
trouvé, et rien sinon.
</para>

<tag:description get-file-properties>
<var filename>
</tag:description>

<tag:description include>
<var filename>
[alt=<var action>]
[verbatim=true]
</tag:description>

;;;
;;;    Debugging
;;;

<subsection "Debugging">

<tag:description debugmode>
<var string>
</tag:description>

<tag:description function-def>
<var nom>
</tag:description>

<tag:description debugging-on>
<var nom>
</tag:description>

<tag:description debugging-off>
<var nom>
</tag:description>

;;;
;;;    Misc
;;;

<subsection "Miscellaneous">

<tag:description date>
[epoch]
</tag:description>

<tag:description timer>
</tag:description>

<tag:description __file__>
</tag:description>

<tag:description __line__>
</tag:description>

<tag:description version>
</tag:description>

<tag:description comment complex>
</tag:description>

<section Bugs>

<para>
When a tag name is not followed by a space or a closing bracket,
expansion is wrong.  For instance, this comment
<pre>
    <html:comment>this is a comment</html:comment>
</pre>
will cause trouble whereas this one
<pre>
    <html:comment> this is a comment</html:comment>
</pre>
is correctly parsed.
</para>

<footer>
